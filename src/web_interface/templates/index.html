        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>RAG_Scraper // Data Extraction Terminal</title>
            <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;700&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
            <style>
                :root {
                    --bg-primary: #0a0a0a;
                    --bg-secondary: #111111;
                    --bg-tertiary: #1a1a1a;
                    --accent-green: #00ff88;
                    --accent-amber: #ffaa00;
                    --accent-cyan: #00aaff;
                    --text-primary: #ffffff;
                    --text-secondary: #cccccc;
                    --text-muted: #888888;
                    --border-glow: rgba(0, 255, 136, 0.3);
                    --shadow-neon: 0 0 20px rgba(0, 255, 136, 0.1);
                }

                * {
                    margin: 0;
                    padding: 0;
                    box-sizing: border-box;
                }

                body {
                    font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
                    background: var(--bg-primary);
                    color: var(--text-primary);
                    min-height: 100vh;
                    background-image: 
                        radial-gradient(circle at 25% 25%, rgba(0, 255, 136, 0.1) 0%, transparent 50%),
                        radial-gradient(circle at 75% 75%, rgba(255, 170, 0, 0.1) 0%, transparent 50%);
                    overflow-x: hidden;
                }

                .matrix-bg {
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    pointer-events: none;
                    z-index: 0;
                    opacity: 0.1;
                }

                .main-container {
                    position: relative;
                    z-index: 10;
                    max-width: 1200px;
                    margin: 0 auto;
                    padding: 2rem;
                }

                .header {
                    text-align: center;
                    margin-bottom: 3rem;
                    position: relative;
                }

                .header::before {
                    content: '';
                    position: absolute;
                    top: -10px;
                    left: 50%;
                    transform: translateX(-50%);
                    width: 100px;
                    height: 2px;
                    background: linear-gradient(90deg, transparent, var(--accent-green), transparent);
                    animation: scan 2s ease-in-out infinite;
                }

                @keyframes scan {
                    0%, 100% { opacity: 0.3; width: 100px; }
                    50% { opacity: 1; width: 200px; }
                }

                .title {
                    font-family: 'JetBrains Mono', monospace;
                    font-size: clamp(2rem, 5vw, 3.5rem);
                    font-weight: 700;
                    background: linear-gradient(45deg, var(--accent-green), var(--accent-cyan));
                    -webkit-background-clip: text;
                    -webkit-text-fill-color: transparent;
                    background-clip: text;
                    margin-bottom: 0.5rem;
                    letter-spacing: -0.02em;
                }

                .subtitle {
                    font-family: 'JetBrains Mono', monospace;
                    font-size: 1rem;
                    color: var(--text-primary);
                    margin-bottom: 1rem;
                }

                .status-bar {
                    font-family: 'JetBrains Mono', monospace;
                    font-size: 0.875rem;
                    color: var(--accent-green);
                    border: 1px solid var(--border-glow);
                    padding: 0.5rem 1rem;
                    border-radius: 0;
                    background: rgba(0, 255, 136, 0.05);
                    display: inline-block;
                    box-shadow: var(--shadow-neon);
                }

                .extraction-panel {
                    background: var(--bg-secondary);
                    border: 1px solid rgba(255, 255, 255, 0.1);
                    border-radius: 0;
                    padding: 2rem;
                    margin-bottom: 2rem;
                    position: relative;
                    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
                }

                .extraction-panel::before {
                    content: '';
                    position: absolute;
                    top: 0;
                    left: 0;
                    right: 0;
                    height: 1px;
                    background: linear-gradient(90deg, transparent, var(--accent-green), transparent);
                }

                .panel-header {
                    font-family: 'JetBrains Mono', monospace;
                    font-size: 0.875rem;
                    color: var(--accent-green);
                    margin-bottom: 1.5rem;
                    text-transform: uppercase;
                    letter-spacing: 0.1em;
                }

                .data-flow {
                    display: flex;
                    align-items: center;
                    justify-content: space-between;
                    margin-bottom: 1.5rem;
                    flex-wrap: wrap;
                    gap: 0.8rem;
                    opacity: 0.4;
                    transition: all 0.3s ease;
                }

                .data-flow.active {
                    opacity: 1;
                }

                .data-flow.active .flow-step {
                    animation: pipeline-pulse 2s ease-in-out infinite;
                }

                .data-flow.active .flow-step:nth-child(1) {
                    animation-delay: 0s;
                }

                .data-flow.active .flow-step:nth-child(2) {
                    animation-delay: 0.5s;
                }

                .data-flow.active .flow-step:nth-child(3) {
                    animation-delay: 1s;
                }

                .flow-step {
                    flex: 1;
                    min-width: 120px;
                    text-align: center;
                    position: relative;
                }

                .flow-icon {
                    width: 45px;
                    height: 45px;
                    margin: 0 auto 0.4rem;
                    border-radius: 50%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 1.1rem;
                    border: 2px solid;
                    transition: all 0.3s ease;
                }

                .flow-step:nth-child(1) .flow-icon {
                    border-color: var(--accent-cyan);
                    background: rgba(0, 170, 255, 0.1);
                    color: var(--accent-cyan);
                }

                .flow-step:nth-child(2) .flow-icon {
                    border-color: var(--accent-amber);
                    background: rgba(255, 170, 0, 0.1);
                    color: var(--accent-amber);
                }

                .flow-step:nth-child(3) .flow-icon {
                    border-color: var(--accent-green);
                    background: rgba(0, 255, 136, 0.1);
                    color: var(--accent-green);
                }

                .flow-step::after {
                    content: '→';
                    position: absolute;
                    right: -20px;
                    top: 30px;
                    color: var(--text-muted);
                    font-size: 1.5rem;
                    animation: pulse 2s ease-in-out infinite;
                }

                .flow-step:last-child::after {
                    display: none;
                }

                @keyframes pulse {
                    0%, 100% { opacity: 0.5; }
                    50% { opacity: 1; }
                }

                @keyframes pipeline-pulse {
                    0%, 100% { 
                        transform: scale(1);
                        box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
                    }
                    50% { 
                        transform: scale(1.05);
                        box-shadow: 0 0 20px rgba(0, 255, 136, 0.6);
                    }
                }

                .flow-label {
                    font-family: 'JetBrains Mono', monospace;
                    font-size: 0.75rem;
                    color: var(--text-secondary);
                    text-transform: uppercase;
                    letter-spacing: 0.05em;
                }

                .input-group {
                    margin-bottom: 2rem;
                    position: relative;
                }

                .form-row {
                    display: flex;
                    gap: 1rem;
                    margin-bottom: 1rem;
                }

                .form-row .input-group {
                    flex: 1;
                    margin-bottom: 0;
                }

                .mode-schema-row {
                    display: flex;
                    gap: 1rem;
                    margin-bottom: 1rem;
                }

                .mode-toggle-container {
                    width: 50%;
                }

                .schema-help-container {
                    width: 50%;
                }

                .target-urls-container {
                    width: 100%; /* Full width within the mode-toggle-container */
                    margin-top: 1rem; /* Space above TARGET_URLS */
                    margin-bottom: 0; /* No bottom margin since it's nested */
                }
                
                .output-dir-container {
                    margin-top: 1rem; /* Space above OUTPUT_DIRECTORY */
                    width: 100% !important; /* Force full width within schema-help-container */
                }
                
                .output-dir-container .input-group {
                    width: 100% !important;
                    margin-bottom: 0 !important;
                }
                
                .output-dir-container .terminal-input {
                    width: 100% !important; /* Force full width input field */
                    box-sizing: border-box !important;
                    min-width: 100% !important;
                    max-width: 100% !important;
                }
                
                /* Override any flex or width constraints */
                .schema-help-container .output-dir-container {
                    flex: 1 1 100% !important;
                    width: 100% !important;
                }

                .analysis-output-row {
                    display: flex;
                    gap: 1rem;
                    margin-bottom: 1rem;
                }
                
                /* Save Settings Styles */
                .save-settings-row {
                    margin: 1rem 0;
                    padding: 1rem;
                    background: rgba(0, 255, 136, 0.05);
                    border: 1px solid rgba(0, 255, 136, 0.2);
                    border-radius: 4px;
                }
                
                .save-settings-toggle {
                    display: flex;
                    align-items: center;
                    justify-content: space-between;
                }
                
                .save-settings-toggle .toggle-label {
                    display: flex;
                    align-items: center;
                    gap: 0.5rem;
                    cursor: pointer;
                    font-family: 'JetBrains Mono', monospace;
                    font-size: 0.875rem;
                    color: var(--accent-green);
                }
                
                .save-settings-toggle input[type="checkbox"] {
                    width: 20px;
                    height: 20px;
                    accent-color: var(--accent-green);
                    cursor: pointer;
                }
                
                .save-settings-toggle .toggle-text {
                    text-transform: uppercase;
                    letter-spacing: 0.05em;
                }
                
                .save-settings-help {
                    font-size: 0.75rem;
                    color: var(--text-muted);
                    line-height: 1.4;
                }
                
                .save-settings-help strong {
                    color: var(--text-secondary);
                }

                .target-analysis-container {
                    width: 50%; /* Same level as OUTPUT_DIRECTORY */
                }

                .output-dir-container {
                    width: 50%; /* Same level as Target Analysis */
                }

                .target-analysis-container .validation-output {
                    margin-top: 0; /* Remove extra spacing */
                }

                .output-dir-container .input-group {
                    margin-bottom: 0; /* Remove extra spacing */
                }

                /* Help text dropdown styling */
                .help-header {
                    cursor: pointer;
                    padding: 0.5rem;
                    background: rgba(255, 255, 255, 0.05);
                    border: 1px solid rgba(255, 255, 255, 0.1);
                    border-radius: 4px;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    font-family: 'JetBrains Mono', monospace;
                    font-size: 0.75rem;
                    color: var(--text-secondary);
                    margin-bottom: 0.5rem;
                }

                .help-header:hover {
                    background: rgba(255, 255, 255, 0.08);
                }

                .help-content {
                    padding: 0.5rem;
                    background: rgba(0, 0, 0, 0.3);
                    border: 1px solid rgba(255, 255, 255, 0.1);
                    border-radius: 4px;
                    font-size: 0.75rem;
                    line-height: 1.4;
                    display: none; /* Start hidden by default */
                }

                .help-content.hidden {
                    display: none !important;
                }

                .help-content.visible {
                    display: block !important;
                }

                .toggle-help {
                    font-weight: bold;
                    color: var(--accent-green);
                }

                /* Compact layout adjustments */
                .mode-schema-row {
                    margin-bottom: 1rem; /* Reduced from 2rem */
                }

                .analysis-output-row {
                    margin-bottom: 1rem; /* Reduced from 2rem */
                }

                .input-group {
                    margin-bottom: 1rem; /* Reduced from 2rem */
                }

                .extraction-panel {
                    padding: 1.5rem; /* Reduced from 2rem */
                }

                .input-label {
                    font-family: 'JetBrains Mono', monospace;
                    font-size: 0.875rem;
                    color: var(--text-secondary);
                    margin-bottom: 0.5rem;
                    display: block;
                    text-transform: uppercase;
                    letter-spacing: 0.05em;
                }

                .terminal-input {
                    width: 100%;
                    background: var(--bg-tertiary);
                    border: 1px solid rgba(255, 255, 255, 0.1);
                    border-radius: 0;
                    color: var(--text-primary);
                    font-family: 'JetBrains Mono', monospace;
                    font-size: 0.875rem;
                    padding: 1rem;
                    transition: all 0.3s ease;
                    resize: vertical;
                }

                .terminal-input:focus {
                    outline: none;
                    border-color: var(--accent-green);
                    box-shadow: 0 0 0 2px rgba(0, 255, 136, 0.2);
                    background: rgba(0, 255, 136, 0.05);
                }

                .terminal-input::placeholder {
                    color: var(--text-muted);
                    font-style: italic;
                }

                .url-textarea {
                    min-height: 120px;
                    font-family: 'JetBrains Mono', monospace;
                }

                .format-grid {
                    display: grid;
                    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
                    gap: 1rem;
                    margin-top: 1rem;
                }

                .format-option {
                    background: var(--bg-tertiary);
                    border: 1px solid rgba(255, 255, 255, 0.1);
                    border-radius: 0;
                    padding: 1rem;
                    cursor: pointer;
                    transition: all 0.3s ease;
                    position: relative;
                    overflow: hidden;
                }

                .format-option::before {
                    content: '';
                    position: absolute;
                    top: 0;
                    left: -100%;
                    width: 100%;
                    height: 2px;
                    background: var(--accent-green);
                    transition: all 0.3s ease;
                }

                .format-option:hover::before,
                .format-option.selected::before {
                    left: 0;
                }

                .format-option:hover {
                    border-color: var(--accent-green);
                    background: rgba(0, 255, 136, 0.05);
                    transform: translateY(-2px);
                }

                .format-option.selected {
                    border-color: var(--accent-green);
                    background: rgba(0, 255, 136, 0.1);
                    box-shadow: var(--shadow-neon);
                }

                .format-option input {
                    display: none;
                }

                .format-title {
                    font-family: 'JetBrains Mono', monospace;
                    font-weight: 600;
                    margin-bottom: 0.5rem;
                    color: var(--text-primary);
                }

                .format-desc {
                    font-size: 0.75rem;
                    color: var(--text-muted);
                    line-height: 1.4;
                }

                .field-selection-grid {
                    display: grid;
                    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                    gap: 0.75rem;
                    margin-top: 1rem;
                }

                .field-option {
                    background: var(--bg-tertiary);
                    border: 1px solid rgba(255, 255, 255, 0.1);
                    border-radius: 0;
                    padding: 0.75rem;
                    cursor: pointer;
                    transition: all 0.3s ease;
                    position: relative;
                    display: flex;
                    align-items: flex-start;
                    gap: 0.5rem;
                }

                .field-option:hover {
                    border-color: var(--accent-amber);
                    background: rgba(255, 170, 0, 0.05);
                }

                .field-option input[type="checkbox"] {
                    margin: 0;
                    accent-color: var(--accent-amber);
                }

                .field-option .field-title {
                    font-family: 'JetBrains Mono', monospace;
                    font-weight: 600;
                    font-size: 0.75rem;
                    color: var(--text-primary);
                    margin-bottom: 0.25rem;
                }

                .field-option .field-desc {
                    font-size: 0.6875rem;
                    color: var(--text-muted);
                    line-height: 1.3;
                }

                .action-bar {
                    display: flex;
                    gap: 1rem;
                    flex-wrap: wrap;
                    margin-top: 2rem;
                }

                .cmd-button {
                    background: var(--bg-tertiary);
                    border: 1px solid rgba(255, 255, 255, 0.2);
                    color: var(--text-primary);
                    font-family: 'JetBrains Mono', monospace;
                    font-size: 0.875rem;
                    padding: 0.75rem 1.5rem;
                    cursor: pointer;
                    transition: all 0.3s ease;
                    position: relative;
                    overflow: hidden;
                    text-transform: uppercase;
                    letter-spacing: 0.05em;
                    font-weight: 500;
                }

                .cmd-button::before {
                    content: '';
                    position: absolute;
                    top: 0;
                    left: -100%;
                    width: 100%;
                    height: 100%;
                    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
                    transition: all 0.5s ease;
                }

                .cmd-button:hover::before {
                    left: 100%;
                }

                .cmd-button.primary {
                    border-color: var(--accent-green);
                    color: var(--accent-green);
                }

                .cmd-button.primary:hover {
                    background: var(--accent-green);
                    color: var(--bg-primary);
                    box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
                }

                .cmd-button:disabled {
                    opacity: 0.5;
                    cursor: not-allowed;
                }

                .terminal-output {
                    background: var(--bg-tertiary);
                    border: 1px solid rgba(255, 255, 255, 0.1);
                    border-radius: 0;
                    padding: 1.5rem;
                    margin-top: 2rem;
                    font-family: 'JetBrains Mono', monospace;
                    font-size: 0.875rem;
                    line-height: 1.6;
                    display: none;
                    position: relative;
                }

                .terminal-output::before {
                    content: '// EXTRACTION OUTPUT';
                    position: absolute;
                    top: -10px;
                    left: 1rem;
                    background: var(--bg-secondary);
                    color: var(--accent-green);
                    padding: 0 0.5rem;
                    font-size: 0.75rem;
                }

                .progress-bar {
                    height: 4px;
                    background: rgba(255, 255, 255, 0.1);
                    margin: 1rem 0;
                    overflow: hidden;
                    position: relative;
                }

                .progress-fill {
                    height: 100%;
                    background: linear-gradient(90deg, var(--accent-green), var(--accent-cyan));
                    width: 0%;
                    transition: width 0.3s ease;
                    position: relative;
                }

                .progress-fill::after {
                    content: '';
                    position: absolute;
                    top: 0;
                    right: 0;
                    width: 20px;
                    height: 100%;
                    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.6));
                    animation: scan-progress 2s ease-in-out infinite;
                }

                @keyframes scan-progress {
                    0%, 100% { transform: translateX(0); opacity: 0; }
                    50% { transform: translateX(-10px); opacity: 1; }
                }

                /* Real-Time Progress Visualization Styles */
                .real-time-progress {
                    margin-top: 1rem;
                    padding: 1rem;
                    background: rgba(26, 26, 26, 0.8);
                    border: 1px solid var(--border-glow);
                    border-radius: 4px;
                }

                .currently-processing {
                    margin-bottom: 1rem;
                    padding: 0.5rem;
                    background: rgba(0, 255, 136, 0.1);
                    border-left: 3px solid var(--accent-green);
                }

                .currently-processing .label {
                    color: var(--accent-green);
                    font-weight: 600;
                    margin-right: 0.5rem;
                }

                .current-url {
                    color: var(--text-primary);
                    font-family: 'JetBrains Mono', monospace;
                    font-size: 0.875rem;
                }

                .current-url.pulsing {
                    animation: pulse 2s ease-in-out infinite;
                }

                @keyframes pulse {
                    0%, 100% { opacity: 1; }
                    50% { opacity: 0.6; }
                }

                .queue-status {
                    margin-bottom: 1rem;
                }

                .queue-metrics {
                    display: grid;
                    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
                    gap: 0.5rem;
                }

                .metric {
                    background: rgba(0, 0, 0, 0.3);
                    padding: 0.5rem;
                    border-radius: 4px;
                    text-align: center;
                }

                .metric-label {
                    display: block;
                    color: var(--text-secondary);
                    font-size: 0.75rem;
                    margin-bottom: 0.25rem;
                }

                .metric-value {
                    display: block;
                    color: var(--accent-cyan);
                    font-family: 'JetBrains Mono', monospace;
                    font-size: 1rem;
                    font-weight: 600;
                }

                .time-estimates {
                    display: flex;
                    gap: 1rem;
                    margin-bottom: 1rem;
                }

                .estimate {
                    flex: 1;
                    padding: 0.5rem;
                    background: rgba(255, 170, 0, 0.1);
                    border-left: 3px solid var(--accent-amber);
                }

                .estimate-label {
                    display: block;
                    color: var(--accent-amber);
                    font-size: 0.75rem;
                    margin-bottom: 0.25rem;
                }

                .estimate-value {
                    display: block;
                    color: var(--text-primary);
                    font-family: 'JetBrains Mono', monospace;
                    font-size: 0.875rem;
                    font-weight: 600;
                }

                .discovery-notifications {
                    max-height: 200px;
                    overflow-y: auto;
                }

                .notification {
                    padding: 0.5rem;
                    margin-bottom: 0.5rem;
                    background: rgba(0, 170, 255, 0.1);
                    border-left: 3px solid var(--accent-cyan);
                    border-radius: 4px;
                    animation: slideIn 0.3s ease-out;
                }

                @keyframes slideIn {
                    from { opacity: 0; transform: translateY(-10px); }
                    to { opacity: 1; transform: translateY(0); }
                }

                .notification .icon {
                    margin-right: 0.5rem;
                    color: var(--accent-cyan);
                }

                .notification .message {
                    color: var(--text-primary);
                    font-size: 0.875rem;
                }

                .validation-output {
                    margin-top: 0.5rem;
                    font-family: 'JetBrains Mono', monospace;
                    font-size: 0.75rem;
                }

                .valid-url {
                    color: var(--accent-green);
                }

                .invalid-url {
                    color: #ff5555;
                }

                .file-links {
                    display: flex;
                    flex-direction: column;
                    gap: 0.5rem;
                    margin-top: 1rem;
                }

                .file-link {
                    display: inline-flex;
                    align-items: center;
                    color: var(--accent-cyan);
                    text-decoration: none;
                    font-family: 'JetBrains Mono', monospace;
                    font-size: 0.875rem;
                    padding: 0.5rem 1rem;
                    border: 1px solid rgba(0, 170, 255, 0.3);
                    background: rgba(0, 170, 255, 0.1);
                    transition: all 0.3s ease;
                }

                .file-link:hover {
                    border-color: var(--accent-cyan);
                    background: rgba(0, 170, 255, 0.2);
                    transform: translateX(5px);
                }

                .file-link::before {
                    content: '📁';
                    margin-right: 0.5rem;
                }

                .success {
                    border-color: var(--accent-green);
                    background: rgba(0, 255, 136, 0.1);
                    color: var(--text-primary);
                }

                .error {
                    border-color: #ff5555;
                    background: rgba(255, 85, 85, 0.1);
                    color: var(--text-primary);
                }

                /* Scraping Mode Selector Styles */
                .scraping-mode-selector {
                    margin-bottom: 1rem;
                }

                .mode-toggle-group {
                    display: grid;
                    grid-template-columns: 1fr 1fr;
                    gap: 0.75rem;
                    margin-top: 0.75rem;
                }

                .mode-option {
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    padding: 1rem;
                    border: 1px solid rgba(255, 255, 255, 0.2);
                    background: var(--bg-tertiary);
                    cursor: pointer;
                    transition: all 0.3s ease;
                    position: relative;
                    text-align: center;
                }

                .mode-option input[type="radio"] {
                    display: none;
                }

                .mode-option:hover {
                    border-color: var(--accent-cyan);
                    background: rgba(0, 170, 255, 0.1);
                    transform: translateY(-2px);
                }

                .mode-option.active {
                    border-color: var(--accent-green);
                    background: rgba(0, 255, 136, 0.1);
                    box-shadow: 0 0 15px rgba(0, 255, 136, 0.2);
                }

                .mode-icon {
                    font-size: 1.5rem;
                    margin-bottom: 0.5rem;
                }

                .mode-title {
                    font-family: 'JetBrains Mono', monospace;
                    font-weight: 600;
                    font-size: 0.875rem;
                    color: var(--text-primary);
                    margin-bottom: 0.25rem;
                }

                .mode-desc {
                    font-size: 0.75rem;
                    color: var(--text-muted);
                    line-height: 1.3;
                }

                /* Multi-Page Configuration Panel Styles */
                .config-panel-header {
                    cursor: pointer;
                    transition: all 0.3s ease;
                    position: relative;
                }

                .config-panel-header:hover {
                    background: rgba(255, 255, 255, 0.05);
                }

                .config-toggle {
                    display: flex;
                    align-items: center;
                    justify-content: space-between;
                    width: 100%;
                    cursor: pointer;
                    font-family: 'JetBrains Mono', monospace;
                    font-size: 0.875rem;
                    color: var(--accent-amber);
                    padding: 0.75rem;
                    border: 1px solid rgba(255, 170, 0, 0.3);
                    background: rgba(255, 170, 0, 0.05);
                    transition: all 0.3s ease;
                }

                .config-icon {
                    margin-right: 0.5rem;
                    font-size: 1rem;
                }

                .expand-icon {
                    transition: transform 0.3s ease;
                    font-family: monospace;
                    color: var(--accent-amber);
                }

                .expand-icon.expanded {
                    transform: rotate(180deg);
                }

                .config-panel {
                    overflow-y: auto;
                    overflow-x: hidden;
                    transition: all 0.4s ease;
                    border: 1px solid rgba(255, 170, 0, 0.2);
                    border-top: none;
                    background: var(--bg-tertiary);
                    /* Custom scrollbar for terminal theme */
                    scrollbar-width: thin;
                    scrollbar-color: var(--accent-green) var(--bg-secondary);
                }
                
                /* Custom scrollbar styling for config panel */
                .config-panel::-webkit-scrollbar {
                    width: 8px;
                }
                
                .config-panel::-webkit-scrollbar-track {
                    background: var(--bg-secondary);
                    border: 1px solid rgba(0, 255, 136, 0.1);
                }
                
                .config-panel::-webkit-scrollbar-thumb {
                    background: var(--accent-green);
                    border: 1px solid rgba(0, 255, 136, 0.3);
                }
                
                .config-panel::-webkit-scrollbar-thumb:hover {
                    background: rgba(0, 255, 136, 0.8);
                }

                .config-panel.collapsed {
                    max-height: 0;
                    opacity: 0;
                    border-color: transparent;
                }

                .config-panel:not(.collapsed) {
                    max-height: 600px;
                    opacity: 1;
                    padding: 1.5rem;
                }

                /* Advanced Options Panel Styling */
                .advanced-options-panel {
                    max-height: 600px;
                    opacity: 1;
                    overflow-y: auto;
                    overflow-x: hidden;
                    transition: max-height 0.3s ease, opacity 0.3s ease, padding 0.3s ease;
                    padding: 1.5rem;
                    border: 1px solid rgba(255, 170, 0, 0.2);
                    border-top: none;
                    background: var(--bg-tertiary);
                    /* Custom scrollbar for terminal theme */
                    scrollbar-width: thin;
                    scrollbar-color: var(--accent-amber) var(--bg-secondary);
                }
                
                /* Custom scrollbar styling for webkit browsers */
                .advanced-options-panel::-webkit-scrollbar {
                    width: 8px;
                }
                
                .advanced-options-panel::-webkit-scrollbar-track {
                    background: var(--bg-secondary);
                    border: 1px solid rgba(255, 170, 0, 0.1);
                }
                
                .advanced-options-panel::-webkit-scrollbar-thumb {
                    background: var(--accent-amber);
                    border: 1px solid rgba(255, 170, 0, 0.3);
                }
                
                .advanced-options-panel::-webkit-scrollbar-thumb:hover {
                    background: rgba(255, 170, 0, 0.8);
                }

                .advanced-options-panel.collapsed {
                    max-height: 0;
                    opacity: 0;
                    padding: 0 1.5rem;
                    border-color: transparent;
                }

                /* AI Enhancement Panel Styling */
                .ai-enhancement-panel {
                    max-height: none;
                    height: auto;
                    overflow-y: visible;
                    background: var(--bg-primary);
                    border: 1px solid var(--border-color);
                    border-radius: 3px;
                    padding: 1.5rem;
                    margin-top: 0.5rem;
                    transition: all 0.3s ease;
                    opacity: 1;
                }

                .ai-enhancement-panel::-webkit-scrollbar {
                    width: 6px;
                }

                .ai-enhancement-panel::-webkit-scrollbar-track {
                    background: var(--bg-secondary);
                    border-radius: 3px;
                }

                .ai-enhancement-panel::-webkit-scrollbar-thumb {
                    background: rgba(0, 255, 136, 0.5);
                    border-radius: 3px;
                }

                .ai-enhancement-panel::-webkit-scrollbar-thumb:hover {
                    background: rgba(0, 255, 136, 0.8);
                }

                .ai-enhancement-panel.collapsed {
                    max-height: 0;
                    opacity: 0;
                    padding: 0 1.5rem;
                    border-color: transparent;
                }

                .ai-config-options {
                    transition: all 0.3s ease;
                    opacity: 1;
                    max-height: none;
                    height: auto;
                    overflow: visible;
                }

                .ai-config-options.collapsed {
                    opacity: 0;
                    max-height: 0;
                    overflow: hidden;
                }

                .feature-toggles-grid {
                    display: grid;
                    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                    gap: 0.75rem;
                    margin-top: 0.5rem;
                }

                .feature-toggle {
                    display: flex;
                    align-items: center;
                    gap: 0.5rem;
                    padding: 0.5rem;
                    background: var(--bg-secondary);
                    border-radius: 3px;
                    cursor: pointer;
                    transition: all 0.2s ease;
                    border: 1px solid transparent;
                }

                .feature-toggle:hover {
                    background: var(--bg-tertiary);
                    border-color: var(--accent-cyan);
                }

                .feature-toggle input[type="checkbox"] {
                    margin: 0;
                }

                .feature-name {
                    font-family: 'JetBrains Mono', monospace;
                    font-size: 0.75rem;
                    color: var(--text-primary);
                    font-weight: 500;
                }

                .service-status {
                    display: flex;
                    align-items: center;
                    gap: 0.5rem;
                    padding: 0.5rem;
                    background: var(--bg-secondary);
                    border-radius: 3px;
                    font-family: 'JetBrains Mono', monospace;
                    font-size: 0.75rem;
                }

                .status-dot {
                    width: 8px;
                    height: 8px;
                    border-radius: 50%;
                    background: var(--text-muted);
                    transition: background 0.3s ease;
                }

                .status-dot.connected {
                    background: var(--accent-green);
                }

                .status-dot.disconnected {
                    background: var(--accent-red);
                }

                .status-dot.checking {
                    background: var(--accent-amber);
                    animation: pulse 2s infinite;
                }

                @keyframes pulse {
                    0%, 100% { opacity: 1; }
                    50% { opacity: 0.5; }
                }

                .ai-enhancement-header .config-toggle-header {
                    cursor: pointer;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    padding: 0.75rem;
                    background: var(--bg-secondary);
                    border-radius: 3px;
                    transition: all 0.2s ease;
                    border: 1px solid var(--border-color);
                }
                
                /* Advanced Options Header Left Alignment */
                .advanced-options-header .config-toggle-header {
                    cursor: pointer;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    padding: 0.75rem;
                    background: var(--bg-secondary);
                    border-radius: 3px;
                    transition: all 0.2s ease;
                    border: 1px solid var(--border-color);
                    text-align: left;
                    margin-left: 0;
                }
                
                .advanced-options-header .config-toggle-header:hover {
                    background: var(--bg-tertiary);
                    border-color: var(--accent-amber);
                }
                
                /* Full-width Options Layout */
                .options-layout-container {
                    display: block;
                    width: 100%;
                    margin-top: 1rem;
                    margin-left: 0;
                    margin-right: 0;
                    grid-column: 1 / -1; /* Span all columns in grid */
                }
                
                .advanced-options-section {
                    width: 100%;
                    max-width: 100%;
                    margin-bottom: 2rem;
                    margin-left: 0;
                    margin-right: 0;
                    float: none;
                    clear: both;
                }
                
                .ai-enhancement-section {
                    width: 100%;
                    max-width: 100%;
                    margin-bottom: 2rem;
                    margin-left: 0;
                    margin-right: 0;
                    float: none;
                    clear: both;
                }
                
                .ai-enhancement-section .config-item {
                    margin-bottom: 1rem;
                }
                
                .ai-enhancement-section .ai-enhancement-header {
                    margin-bottom: 0;
                }
                
                .ai-enhancement-section .ai-enhancement-panel {
                    border: 1px solid rgba(0, 170, 255, 0.2);
                    border-top: none;
                    background: var(--bg-tertiary);
                }
                
                /* Ensure no conflicting styles */
                .options-layout-container * {
                    box-sizing: border-box;
                }
                
                .advanced-options-section *,
                .ai-enhancement-section * {
                    box-sizing: border-box;
                }

                .ai-enhancement-header .config-toggle-header:hover {
                    background: var(--bg-tertiary);
                    border-color: var(--accent-cyan);
                }

                .config-grid {
                    display: grid;
                    grid-template-columns: repeat(2, 1fr);
                    gap: 1.5rem;
                }
                
                /* Responsive: single column on smaller screens */
                @media (max-width: 768px) {
                    .config-grid {
                        grid-template-columns: 1fr;
                    }
                }

                .config-item {
                    display: flex;
                    flex-direction: column;
                    gap: 0.5rem;
                }

                .config-label {
                    font-family: 'JetBrains Mono', monospace;
                    font-size: 0.75rem;
                    color: var(--accent-green);
                    font-weight: 600;
                    text-transform: uppercase;
                    letter-spacing: 0.05em;
                }

                .config-input {
                    font-size: 0.875rem;
                    padding: 0.5rem;
                }

                .terminal-slider {
                    -webkit-appearance: none;
                    appearance: none;
                    height: 4px;
                    background: rgba(255, 255, 255, 0.1);
                    outline: none;
                    border-radius: 0;
                    cursor: pointer;
                }

                .terminal-slider::-webkit-slider-thumb {
                    -webkit-appearance: none;
                    appearance: none;
                    width: 16px;
                    height: 16px;
                    background: var(--accent-green);
                    cursor: pointer;
                    border-radius: 0;
                    border: 1px solid var(--accent-green);
                    box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
                }

                .terminal-slider::-moz-range-thumb {
                    width: 16px;
                    height: 16px;
                    background: var(--accent-green);
                    cursor: pointer;
                    border-radius: 0;
                    border: 1px solid var(--accent-green);
                    box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
                }

                .slider-value {
                    font-family: 'JetBrains Mono', monospace;
                    font-size: 0.75rem;
                    color: var(--accent-amber);
                    margin-top: 0.25rem;
                }

                .config-desc {
                    font-size: 0.6875rem;
                    color: var(--text-muted);
                    line-height: 1.4;
                    font-style: italic;
                }

                .terminal-checkbox {
                    margin-right: 0.5rem;
                    accent-color: var(--accent-green);
                    transform: scale(1.2);
                }

                @media (max-width: 768px) {
                    .main-container {
                        padding: 1rem;
                    }
                    
                    .data-flow {
                        flex-direction: column;
                    }
                    
                    .flow-step::after {
                        display: none;
                    }
                    
                    .action-bar {
                        flex-direction: column;
                    }
                }

                /* Custom scrollbar */
                ::-webkit-scrollbar {
                    width: 8px;
                }

                ::-webkit-scrollbar-track {
                    background: var(--bg-secondary);
                }

                ::-webkit-scrollbar-thumb {
                    background: var(--accent-green);
                    border-radius: 4px;
                }

                ::-webkit-scrollbar-thumb:hover {
                    background: var(--accent-cyan);
                }

                /* Enhanced Results Display Styles */
                .results-container {
                    margin-top: 3rem;
                    border: 1px solid var(--border-color);
                    border-radius: 4px;
                    background: var(--bg-secondary);
                    overflow: hidden;
                    clear: both;
                    position: relative;
                    z-index: 1;
                }

                .results-header {
                    background: var(--bg-tertiary);
                    padding: 0.75rem 1rem;
                    border-bottom: 1px solid var(--border-color);
                }

                .results-header h3 {
                    margin: 0;
                    font-family: 'JetBrains Mono', monospace;
                    font-size: 0.875rem;
                    color: var(--accent-green);
                    text-transform: uppercase;
                    letter-spacing: 0.1em;
                }

                .results-content {
                    max-height: 400px;
                    overflow-y: auto;
                }

                .no-results {
                    padding: 2rem;
                    text-align: center;
                    color: var(--text-muted);
                }

                .no-results .status-message {
                    font-family: 'JetBrains Mono', monospace;
                    font-size: 0.875rem;
                    margin-bottom: 0.5rem;
                }

                .no-results .status-subtitle {
                    font-size: 0.75rem;
                    opacity: 0.7;
                }

                .sites-results {
                    padding: 1rem;
                }

                .site-result {
                    margin-bottom: 1.5rem;
                    border: 1px solid var(--border-color);
                    border-radius: 4px;
                    background: var(--bg-primary);
                    overflow: hidden;
                }

                .site-result:last-child {
                    margin-bottom: 0;
                }

                .site-header {
                    background: var(--bg-tertiary);
                    padding: 0.75rem 1rem;
                    border-bottom: 1px solid var(--border-color);
                    cursor: pointer;
                    transition: all 0.2s ease;
                }

                .site-header:hover {
                    background: var(--bg-secondary);
                }

                .site-url {
                    font-family: 'JetBrains Mono', monospace;
                    font-size: 0.8rem;
                    color: var(--accent-cyan);
                    margin-bottom: 0.25rem;
                    word-break: break-all;
                }

                .pages-summary {
                    font-family: 'JetBrains Mono', monospace;
                    font-size: 0.75rem;
                    color: var(--accent-amber);
                    display: flex;
                    align-items: center;
                    gap: 1rem;
                }

                .expand-toggle {
                    margin-left: auto;
                    color: var(--text-muted);
                    transition: transform 0.2s ease;
                }

                .expand-toggle.expanded {
                    transform: rotate(180deg);
                }

                .pages-list {
                    padding: 1rem;
                    border-top: 1px solid var(--border-color);
                    display: none;
                }

                .pages-list.expanded {
                    display: block;
                }

                .page-item {
                    display: flex;
                    align-items: center;
                    padding: 0.5rem;
                    margin-bottom: 0.5rem;
                    border: 1px solid var(--border-color);
                    border-radius: 3px;
                    background: var(--bg-secondary);
                    font-family: 'JetBrains Mono', monospace;
                    font-size: 0.75rem;
                }

                .page-item:last-child {
                    margin-bottom: 0;
                }

                .page-item.status-success {
                    border-left: 3px solid var(--accent-green);
                }

                .page-item.status-failed {
                    border-left: 3px solid var(--accent-red);
                }

                .page-url {
                    flex: 1;
                    color: var(--text-primary);
                    margin-right: 1rem;
                    word-break: break-all;
                }

                .page-status {
                    padding: 0.2rem 0.5rem;
                    border-radius: 2px;
                    font-size: 0.6875rem;
                    font-weight: bold;
                    text-transform: uppercase;
                    letter-spacing: 0.05em;
                    margin-right: 0.5rem;
                }

                .page-status.success {
                    background: var(--accent-green);
                    color: var(--bg-primary);
                }

                .page-status.failed {
                    background: var(--accent-red);
                    color: var(--bg-primary);
                }

                .page-time {
                    color: var(--text-muted);
                    font-size: 0.6875rem;
                    min-width: 60px;
                    text-align: right;
                }

                .show-all-link {
                    margin-top: 0.5rem;
                    padding: 0.5rem;
                    text-align: center;
                    color: var(--accent-cyan);
                    cursor: pointer;
                    border: 1px dashed var(--border-color);
                    border-radius: 3px;
                    transition: all 0.2s ease;
                    font-family: 'JetBrains Mono', monospace;
                    font-size: 0.75rem;
                }

                .show-all-link:hover {
                    background: var(--bg-tertiary);
                    border-color: var(--accent-cyan);
                }

                .processing-stats {
                    display: flex;
                    gap: 1rem;
                    font-size: 0.6875rem;
                    color: var(--text-muted);
                }

                .stat-item {
                    display: flex;
                    align-items: center;
                    gap: 0.25rem;
                }

                .stat-icon {
                    width: 8px;
                    height: 8px;
                    border-radius: 50%;
                }

                .stat-icon.success {
                    background: var(--accent-green);
                }

                .stat-icon.failed {
                    background: var(--accent-red);
                }

                /* Page Relationships Display Styles */
                .relationship-enabled {
                    position: relative;
                }

                .relationship-tree {
                    margin-top: 1rem;
                    padding: 1rem;
                    border: 1px solid var(--border-color);
                    border-radius: 4px;
                    background: var(--bg-tertiary);
                }

                .relationship-tree-header {
                    font-family: 'JetBrains Mono', monospace;
                    font-size: 0.875rem;
                    color: var(--accent-green);
                    text-transform: uppercase;
                    letter-spacing: 0.1em;
                    margin-bottom: 1rem;
                    display: flex;
                    align-items: center;
                    gap: 0.5rem;
                }

                .page-item.relationship-root {
                    border-left: 4px solid var(--accent-green);
                    background: linear-gradient(90deg, rgba(0, 255, 136, 0.1) 0%, transparent 100%);
                }

                .page-item.relationship-child {
                    border-left: 4px solid var(--accent-cyan);
                    background: linear-gradient(90deg, rgba(0, 204, 255, 0.05) 0%, transparent 100%);
                }

                .page-item.relationship-orphaned {
                    border-left: 4px solid var(--accent-amber);
                    background: linear-gradient(90deg, rgba(255, 193, 7, 0.1) 0%, transparent 100%);
                }

                .relationship-indicator {
                    display: inline-flex;
                    align-items: center;
                    padding: 0.2rem 0.5rem;
                    border-radius: 3px;
                    font-family: 'JetBrains Mono', monospace;
                    font-size: 0.6875rem;
                    font-weight: bold;
                    text-transform: uppercase;
                    letter-spacing: 0.05em;
                    margin-right: 0.5rem;
                }

                .relationship-indicator.ROOT {
                    background: var(--accent-green);
                    color: var(--bg-primary);
                }

                .relationship-indicator.child {
                    background: var(--accent-cyan);
                    color: var(--bg-primary);
                    font-size: 0.75rem;
                }

                .relationship-indicator.orphaned {
                    background: var(--accent-amber);
                    color: var(--bg-primary);
                }

                .indentation {
                    display: inline-block;
                    margin-right: 0.5rem;
                    color: var(--text-muted);
                    font-family: 'JetBrains Mono', monospace;
                }

                .depth-0 .indentation::before {
                    content: '';
                }

                .depth-1 .indentation::before {
                    content: '  └─ ';
                    color: var(--accent-cyan);
                }

                .depth-2 .indentation::before {
                    content: '    └─ ';
                    color: var(--accent-cyan);
                }

                .depth-3 .indentation::before {
                    content: '      └─ ';
                    color: var(--accent-cyan);
                }

                .depth-4 .indentation::before {
                    content: '        └─ ';
                    color: var(--accent-cyan);
                }

                .depth-5 .indentation::before {
                    content: '          └─ ';
                    color: var(--accent-cyan);
                }

                .parent-reference {
                    font-size: 0.6875rem;
                    color: var(--text-muted);
                    font-style: italic;
                    margin-left: 0.5rem;
                }

                .discovery-info {
                    font-size: 0.6875rem;
                    color: var(--accent-amber);
                    margin-left: 0.5rem;
                    padding: 0.1rem 0.3rem;
                    background: rgba(255, 193, 7, 0.1);
                    border-radius: 2px;
                }

                .children-count {
                    font-size: 0.6875rem;
                    color: var(--accent-green);
                    margin-left: 0.5rem;
                    padding: 0.1rem 0.3rem;
                    background: rgba(0, 255, 136, 0.1);
                    border-radius: 2px;
                }

                .depth-level {
                    font-size: 0.6875rem;
                    color: var(--text-muted);
                    margin-left: 0.5rem;
                }

                .relationship-stats {
                    margin-top: 1rem;
                    padding: 0.75rem;
                    background: var(--bg-secondary);
                    border-radius: 3px;
                    border: 1px solid var(--border-color);
                    font-family: 'JetBrains Mono', monospace;
                    font-size: 0.75rem;
                }

                .relationship-stats-grid {
                    display: grid;
                    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
                    gap: 0.5rem;
                }

                .stat-row {
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                }

                .stat-label {
                    color: var(--text-muted);
                }

                .stat-value {
                    color: var(--accent-green);
                    font-weight: bold;
                }

                .tree-toggle {
                    cursor: pointer;
                    margin-left: 0.5rem;
                    padding: 0.2rem;
                    border-radius: 2px;
                    transition: all 0.2s ease;
                    font-size: 0.6875rem;
                }

                .tree-toggle:hover {
                    background: var(--bg-secondary);
                    color: var(--accent-cyan);
                }

                .tree-toggle.expanded {
                    transform: rotate(180deg);
                }

                .children-list {
                    margin-left: 1rem;
                    margin-top: 0.5rem;
                    border-left: 1px dashed var(--border-color);
                    padding-left: 1rem;
                    display: none;
                }

                .children-list.expanded {
                    display: block;
                }

                .broken-relationship {
                    border-left-color: var(--accent-red) !important;
                    background: linear-gradient(90deg, rgba(220, 53, 69, 0.1) 0%, transparent 100%);
                }

                .relationship-warning {
                    color: var(--accent-red);
                    font-size: 0.6875rem;
                    margin-left: 0.5rem;
                    padding: 0.1rem 0.3rem;
                    background: rgba(220, 53, 69, 0.1);
                    border-radius: 2px;
                }

                .relationship-tooltip {
                    position: relative;
                    cursor: help;
                    margin-left: 0.25rem;
                    color: var(--accent-cyan);
                    font-size: 0.75rem;
                }

                .relationship-tooltip:hover::after {
                    content: attr(data-tooltip);
                    position: absolute;
                    bottom: 100%;
                    left: 50%;
                    transform: translateX(-50%);
                    background: var(--bg-primary);
                    color: var(--text-primary);
                    padding: 0.5rem;
                    border-radius: 4px;
                    border: 1px solid var(--border-color);
                    white-space: nowrap;
                    z-index: 1000;
                    font-size: 0.6875rem;
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
                }

                .orphaned-section {
                    margin-top: 1rem;
                    padding: 0.75rem;
                    background: rgba(255, 193, 7, 0.05);
                    border: 1px dashed var(--accent-amber);
                    border-radius: 4px;
                }

                .orphaned-section-header {
                    font-family: 'JetBrains Mono', monospace;
                    font-size: 0.75rem;
                    color: var(--accent-amber);
                    text-transform: uppercase;
                    letter-spacing: 0.1em;
                    margin-bottom: 0.5rem;
                }

                .highlight-relationship-chain .page-item {
                    opacity: 0.3;
                    transition: opacity 0.2s ease;
                }

                .highlight-relationship-chain .page-item.highlighted {
                    opacity: 1;
                    box-shadow: 0 0 10px rgba(0, 204, 255, 0.3);
                }
                
                /* File Upload Styles */
                {{ file_upload_styles | safe }}
            </style>
        </head>
        <body>
            <div class="matrix-bg"></div>
            
            <div class="main-container">
                <header class="header">
                    <h1 class="title">RAG Scraper</h1>
                    <p class="subtitle">DATA EXTRACTION TERMINAL</p>
                    <div class="status-bar">SYSTEM_READY // AWAITING_TARGET_URLs</div>
                </header>

                <div class="extraction-panel">
                    <div class="panel-header">DATA FLOW PIPELINE</div>
                    
                    <div class="data-flow">
                        <div class="flow-step">
                            <div class="flow-icon">🌐</div>
                            <div class="flow-label">WEB_SCAN</div>
                        </div>
                        <div class="flow-step">
                            <div class="flow-icon">⚡</div>
                            <div class="flow-label">EXTRACT</div>
                        </div>
                        <div class="flow-step">
                            <div class="flow-icon">📊</div>
                            <div class="flow-label">RAG_DATA</div>
                        </div>
                    </div>

                    <form id="scrapeForm" enctype="multipart/form-data">
                        <div class="form-row">
                            <div class="input-group">
                                <label class="input-label" for="industry">INDUSTRY_TYPE:</label>
                                {{ industry_dropdown|safe }}
                                {{ help_text|safe }}
                            </div>
                            
                            <!-- Restaurant Schema Type Selection -->
                            <div class="input-group" id="restaurant-schema-type-group">
                                {{ restaurant_schema_type_dropdown|safe }}
                            </div>
                        </div>
                        
                        <!-- Mode selector and Schema help text on same row -->
                        <div class="mode-schema-row">
                            <div class="mode-toggle-container">
                                {{ input_mode_toggle | safe }}
                                
                                <!-- TARGET_URLS on the left -->
                                <div class="target-urls-container">
                                    <div class="input-group" id="url-input-group">
                                        <label class="input-label" for="urls">TARGET_URLS:</label>
                                        <textarea 
                                            id="urls" 
                                            name="urls" 
                                            class="terminal-input url-textarea"
                                            placeholder="https://restaurant1.com
https://restaurant2.com
https://restaurant3.com
// Enter restaurant URLs to extract..."
                                            required></textarea>
                                    </div>
                                </div>
                            </div>
                            <div class="schema-help-container">
                                {{ restaurant_schema_type_help_text|safe }}
                                
                                <!-- OUTPUT_DIRECTORY under Schema Type Information -->
                                <div class="output-dir-container">
                                    <div class="input-group">
                                        <label class="input-label" for="outputDir">OUTPUT_DIRECTORY:</label>
                                        <input 
                                            type="text" 
                                            id="outputDir" 
                                            name="outputDir" 
                                            class="terminal-input"
                                            placeholder="~/Downloads // Leave empty for default">
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Target analysis container -->
                        <div class="analysis-output-row">
                            <div class="target-analysis-container">
                                <div id="urlValidation" class="validation-output"></div>
                            </div>
                        </div>
                        
                        <!-- File Upload Area (initially hidden) -->
                        <div id="file-upload-container" style="display: none;">
                            {{ file_upload_area | safe }}
                        </div>
                        
                        <!-- Action Bar -->
                        <div class="action-bar">
                            <button type="submit" form="scrapeForm" id="submitBtn" class="cmd-button primary">EXECUTE_EXTRACTION</button>
                            <button type="button" id="validateBtn" class="cmd-button">VALIDATE_TARGETS</button>
                            <button type="button" id="clearBtn" class="cmd-button">RESET_TERMINAL</button>
                        </div>
                        
                        <!-- Scraping Results - positioned right after action bar -->
                        <div id="resultsContainer" class="results-container" style="display: none;">
                            <div class="results-header">
                                <h3>📊 SCRAPING_RESULTS</h3>
                            </div>
                            <div class="results-content" id="resultsContent">
                                <div class="no-results" id="noResults">
                                    <div class="status-message">No results available</div>
                                    <div class="status-subtitle">Complete a scraping operation to see detailed results</div>
                                </div>
                                <div class="sites-results" id="sitesResults" style="display: none;">
                                    <!-- Site results will be populated here -->
                                </div>
                            </div>
                        </div>
                        
                        <!-- Multi-Page Configuration Panel -->
                        <div class="input-group" data-section="scraping-mode">
                            <div class="scraping-mode-selector">
                                <label class="input-label">SCRAPING_MODE:</label>
                                <div class="mode-toggle-group">
                                    <label class="mode-option" data-mode="single">
                                        <input type="radio" name="scrapingMode" value="single">
                                        <span class="mode-icon">📄</span>
                                        <span class="mode-title">SINGLE_PAGE</span>
                                        <span class="mode-desc">Process each URL as single page</span>
                                    </label>
                                    <label class="mode-option active" data-mode="multi">
                                        <input type="radio" name="scrapingMode" value="multi" checked>
                                        <span class="mode-icon">📚</span>
                                        <span class="mode-title">MULTI_PAGE</span>
                                        <span class="mode-desc">Discover and crawl related pages</span>
                                    </label>
                                </div>
                            </div>
                            
                            <!-- Single Page Configuration Panel -->
                            <div class="config-panel-header" onclick="toggleSinglePageConfig()" id="singlePageHeader" style="display: none;">
                                <label class="input-label config-toggle">
                                    <span class="config-icon">⚙️</span>
                                    SINGLE_PAGE_CONFIG
                                    <span class="expand-icon" id="singleConfigExpandIcon">▼</span>
                                </label>
                            </div>
                            <div id="singlePageConfig" class="config-panel collapsed">
                                <div class="config-grid">
                                    <!-- JavaScript Rendering Options -->
                                    <div class="config-item">
                                        <label class="config-label">
                                            <input 
                                                type="checkbox" 
                                                id="singleEnableJavaScript" 
                                                name="enableJavaScript" 
                                                class="terminal-checkbox" />
                                            ENABLE_JAVASCRIPT_RENDERING
                                        </label>
                                        <div class="config-desc">Enable JavaScript rendering for dynamic content</div>
                                    </div>
                                    
                                    <div class="config-item">
                                        <label class="config-label" for="singleJsTimeout">JS_TIMEOUT_SECONDS:</label>
                                        <input 
                                            type="range" 
                                            id="singleJsTimeout" 
                                            name="jsTimeout" 
                                            class="terminal-slider"
                                            value="30"
                                            min="10"
                                            max="120"
                                            step="10" />
                                        <div class="slider-value">Timeout: <span id="singleJsTimeoutValue">30s</span></div>
                                        <div class="config-desc">Maximum time to wait for JavaScript content</div>
                                    </div>
                                    
                                    <!-- Popup Handling -->
                                    <div class="config-item">
                                        <label class="config-label">
                                            <input 
                                                type="checkbox" 
                                                id="singleEnablePopupHandling" 
                                                name="enablePopupHandling" 
                                                class="terminal-checkbox" 
                                                checked />
                                            ENABLE_POPUP_HANDLING
                                        </label>
                                        <div class="config-desc">Auto-handle restaurant popups (age verification, location, etc.)</div>
                                    </div>
                                    
                                    <!-- Single Page Save Settings -->
                                    <div class="config-section-divider"></div>
                                    <div class="config-item save-settings-section">
                                        {{ single_page_save_settings_toggle | safe }}
                                    </div>
                                    
                                    <!-- Advanced Options Section -->
                                    <div class="config-section-divider"></div>
                                    
                                    <!-- Full-width Options Layout -->
                                    <div class="options-layout-container">
                                        <!-- Advanced Options -->
                                        <div class="advanced-options-section">
                                            <div class="config-item advanced-options-header">
                                                <div class="config-toggle-header" onclick="toggleSinglePageAdvancedOptions();">
                                                    <span class="config-label">🔧 ADVANCED_OPTIONS</span>
                                                    <span class="expand-icon" id="singleAdvancedOptionsIcon">▼</span>
                                                </div>
                                            </div>
                                            
                                            <div id="singleAdvancedOptionsPanel" class="advanced-options-panel collapsed">
                                        <!-- Request Timeout -->
                                        <div class="config-item">
                                            <label class="config-label" for="singleRequestTimeout">REQUEST_TIMEOUT_SECONDS:</label>
                                            <input 
                                                type="number" 
                                                id="singleRequestTimeout" 
                                                name="requestTimeout" 
                                                class="terminal-input config-input"
                                                value="30"
                                                min="5"
                                                max="300"
                                                step="5" />
                                            <div class="config-range-indicator">Range: 5-300 seconds</div>
                                            <div class="config-desc">Maximum time to wait for each page request</div>
                                        </div>
                                        
                                        <!-- Concurrent Requests -->
                                        <div class="config-item">
                                            <label class="config-label" for="singleConcurrentRequests">CONCURRENT_REQUESTS:</label>
                                            <input 
                                                type="range" 
                                                id="singleConcurrentRequests" 
                                                name="concurrentRequests" 
                                                class="terminal-slider"
                                                value="5"
                                                min="1"
                                                max="10"
                                                step="1" />
                                            <div class="slider-value">Concurrent: <span id="singleConcurrentRequestsValue">5</span></div>
                                            <div class="config-desc">Number of simultaneous requests (be respectful to servers)</div>
                                        </div>
                                        
                                        <!-- Follow Redirects -->
                                        <div class="config-item">
                                            <label class="config-label">
                                                <input 
                                                    type="checkbox" 
                                                    id="singleFollowRedirects" 
                                                    name="followRedirects" 
                                                    class="terminal-checkbox" 
                                                    checked />
                                                FOLLOW_REDIRECTS
                                            </label>
                                            <div class="config-desc">Follow HTTP redirects to final destination</div>
                                        </div>
                                            </div>
                                        </div>
                                        
                                        <!-- AI Enhancement Options -->
                                        <div class="ai-enhancement-section">
                                            <div class="config-item ai-enhancement-header">
                                                <div class="config-toggle-header" onclick="toggleSinglePageAIEnhancementOptions()">
                                                    <span class="config-label">🤖 AI_ENHANCEMENT_OPTIONS</span>
                                                    <span class="expand-icon" id="singleAiEnhancementIcon">▼</span>
                                                </div>
                                            </div>
                                            
                                            <div id="singleAiEnhancementPanel" class="ai-enhancement-panel collapsed">
                                            <!-- Enable AI Enhancement Toggle -->
                                            <div class="config-item">
                                                <label class="config-label toggle-switch-label">
                                                    <input 
                                                        type="checkbox" 
                                                        id="singleAiEnhancementEnabled" 
                                                        name="aiEnhancementEnabled" 
                                                        class="terminal-checkbox toggle-switch" 
                                                        onchange="handleSinglePageAIEnhancementToggle()" />
                                                    <span class="toggle-slider"></span>
                                                    ENABLE_AI_ENHANCEMENT
                                                </label>
                                                <div class="config-desc">Enable AI-powered content analysis and extraction enhancement (optional)</div>
                                                <div class="config-warning" style="color: var(--accent-amber); font-size: 0.75rem; margin-top: 0.25rem;">
                                                    ⚠️ AI features are completely optional. Traditional extraction works without AI.
                                                </div>
                                            </div>
                                            
                                            <!-- AI Configuration Options (hidden by default) -->
                                            <div id="singleAiConfigOptions" class="ai-config-options collapsed">
                                                
                                                <!-- LLM Provider Selection -->
                                                <div class="config-item">
                                                    <label class="config-label" for="singleLlmProvider">LLM_PROVIDER:</label>
                                                    <select id="singleLlmProvider" name="llmProvider" class="terminal-input config-input" onchange="handleSinglePageProviderChange()">
                                                        <option value="openai">OpenAI GPT</option>
                                                        <option value="claude">Anthropic Claude</option>
                                                        <option value="ollama">Ollama (Local)</option>
                                                        <option value="llama_cpp">llama.cpp (Local)</option>
                                                        <option value="custom">Custom OpenAI-Compatible</option>
                                                    </select>
                                                    <div class="config-desc">Choose your preferred AI language model provider</div>
                                                </div>
                                                
                                                <!-- Model Selection Dropdown -->
                                                <div class="config-item" id="singleModelSection" style="display: none;">
                                                    <label class="config-label" for="singleModelSelect">MODEL:</label>
                                                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                                                        <select id="singleModelSelect" name="modelSelect" class="terminal-input config-input" style="flex: 1;">
                                                            <option value="">Select model...</option>
                                                        </select>
                                                        <button type="button" 
                                                                id="refreshSingleModelsButton"
                                                                class="terminal-button"
                                                                onclick="refreshSingleModels()"
                                                                style="padding: 0.25rem 0.5rem; font-size: 0.8rem;"
                                                                title="Refresh available models">
                                                            🔄
                                                        </button>
                                                    </div>
                                                    <div class="config-desc">Choose specific model for selected provider</div>
                                                    <div class="config-warning" style="display: none;" id="singleModelWarning">
                                                        ⚠️ Model selection error
                                                    </div>
                                                </div>
                                                
                                                <!-- API Key Input (for external providers) -->
                                                <div class="config-item" id="singleApiKeySection">
                                                    <label class="config-label" for="singleAiApiKey">API_KEY:</label>
                                                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                                                        <input 
                                                            type="password" 
                                                            id="singleAiApiKey" 
                                                            name="aiApiKey" 
                                                            class="terminal-input config-input"
                                                            placeholder="Enter API Key (any format accepted)"
                                                            style="flex: 1;"
                                                            autocomplete="off"
                                                            oninput="handleApiKeyInput('single')" />
                                                        <button type="button" 
                                                                id="toggleSingleApiKeyVisibility"
                                                                class="terminal-button"
                                                                onclick="toggleSingleApiKeyVisibility()"
                                                                style="padding: 0.25rem 0.5rem; font-size: 0.8rem;"
                                                                title="Toggle API key visibility">
                                                            👁️
                                                        </button>
                                                    </div>
                                                    <div class="config-desc">API key for external AI services (stored securely, optional)</div>
                                                    <div class="config-warning" style="display: none;" id="singleApiKeyWarning">
                                                        ⚠️ Invalid API key format
                                                    </div>
                                                </div>
                                                
                                                <!-- Custom Provider Configuration -->
                                                <div class="config-item" id="singleCustomProviderSection" style="display: none;">
                                                    <label class="config-label">CUSTOM_PROVIDER_CONFIG:</label>
                                                    
                                                    <div class="config-subitem">
                                                        <label class="config-label" for="singleCustomProviderName">Provider Name:</label>
                                                        <input 
                                                            type="text" 
                                                            id="singleCustomProviderName" 
                                                            name="customProviderName" 
                                                            class="terminal-input config-input"
                                                            placeholder="e.g., My Local LLM"
                                                            style="margin-bottom: 0.5rem;" />
                                                    </div>
                                                    
                                                    <div class="config-subitem">
                                                        <label class="config-label" for="singleCustomBaseUrl">Base URL:</label>
                                                        <input 
                                                            type="text" 
                                                            id="singleCustomBaseUrl" 
                                                            name="customBaseUrl" 
                                                            class="terminal-input config-input"
                                                            placeholder="https://my-llm.com/v1"
                                                            style="margin-bottom: 0.5rem;" />
                                                    </div>
                                                    
                                                    <div class="config-subitem">
                                                        <label class="config-label" for="singleCustomModelName">Model Name:</label>
                                                        <input 
                                                            type="text" 
                                                            id="singleCustomModelName" 
                                                            name="customModelName" 
                                                            class="terminal-input config-input"
                                                            placeholder="gpt-3.5-turbo"
                                                            style="margin-bottom: 0.5rem;" />
                                                    </div>
                                                    
                                                    <div class="config-desc">Configure custom OpenAI-compatible endpoint</div>
                                                </div>
                                                
                                                <!-- Local Service Status (for local providers) -->
                                                <div class="config-item" id="singleLocalServiceStatus" style="display: none;">
                                                    <div class="config-label">SERVICE_STATUS:</div>
                                                    <div id="singleServiceStatusIndicator" class="service-status">
                                                        <span class="status-dot" id="singleStatusDot"></span>
                                                        <span id="singleStatusText">Checking connection...</span>
                                                    </div>
                                                    <div class="config-desc">Connection status to local AI service</div>
                                                </div>
                                                
                                                <!-- AI Feature Toggles -->
                                                <div class="config-item">
                                                    <div class="config-label">AI_FEATURES:</div>
                                                    <div class="feature-toggles-grid">
                                                        <label class="feature-toggle">
                                                            <input type="checkbox" id="singleNutritionalAnalysis" name="nutritionalAnalysis" checked class="terminal-checkbox" />
                                                            <span class="feature-name">Nutritional Analysis</span>
                                                        </label>
                                                        <label class="feature-toggle">
                                                            <input type="checkbox" id="singlePriceAnalysis" name="priceAnalysis" checked class="terminal-checkbox" />
                                                            <span class="feature-name">Price Analysis</span>
                                                        </label>
                                                        <label class="feature-toggle">
                                                            <input type="checkbox" id="singleCuisineClassification" name="cuisineClassification" checked class="terminal-checkbox" />
                                                            <span class="feature-name">Cuisine Classification</span>
                                                        </label>
                                                        <label class="feature-toggle">
                                                            <input type="checkbox" id="singleMultimodalAnalysis" name="multimodalAnalysis" class="terminal-checkbox" />
                                                            <span class="feature-name">Multi-modal Analysis</span>
                                                        </label>
                                                        <label class="feature-toggle">
                                                            <input type="checkbox" id="singlePatternLearning" name="patternLearning" class="terminal-checkbox" />
                                                            <span class="feature-name">Pattern Learning</span>
                                                        </label>
                                                        <label class="feature-toggle">
                                                            <input type="checkbox" id="singleDynamicPrompts" name="dynamicPrompts" class="terminal-checkbox" />
                                                            <span class="feature-name">Dynamic Prompts</span>
                                                        </label>
                                                    </div>
                                                    <div class="config-desc">Select which AI-powered analysis features to enable</div>
                                                </div>
                                                
                                                <!-- Confidence Threshold Slider -->
                                                <div class="config-item">
                                                    <label class="config-label" for="singleConfidenceThreshold">CONFIDENCE_THRESHOLD:</label>
                                                    <input 
                                                        type="range" 
                                                        id="singleConfidenceThreshold" 
                                                        name="confidenceThreshold" 
                                                        class="terminal-slider"
                                                        value="0.7"
                                                        min="0.1"
                                                        max="1.0"
                                                        step="0.1" 
                                                        oninput="updateSinglePageConfidenceValue(this.value)" />
                                                    <div class="slider-value">Threshold: <span id="singleConfidenceValue">0.7</span></div>
                                                    <div class="config-desc">Minimum confidence required for AI predictions (lower = more results, higher = more accurate)</div>
                                                </div>
                                                
                                                <!-- Custom Questions -->
                                                <div class="config-item">
                                                    <label class="config-label" for="singleCustomQuestions">CUSTOM_QUESTIONS:</label>
                                                    <textarea 
                                                        id="singleCustomQuestions" 
                                                        name="customQuestions" 
                                                        class="terminal-input"
                                                        placeholder="Enter questions (one per line, max 200 chars each)&#10;Example: Are takeout containers eco-friendly?&#10;Example: What's the wifi password policy?"
                                                        rows="3"
                                                        style="width: 100%; resize: vertical; font-family: 'Courier New', monospace;"
                                                        oninput="validateCustomQuestions('single')"
                                                    ></textarea>
                                                    <div class="config-desc" id="singleCustomQuestionsDesc">Add custom questions for AI to answer (200 char limit per question)</div>
                                                </div>
                                                
                                                <!-- AI Settings Persistence Controls -->
                                                <div class="config-section-divider"></div>
                                                <div class="config-item">
                                                    <div class="config-label">🔒 AI_SETTINGS_PERSISTENCE</div>
                                                    <div class="config-desc" style="margin-bottom: 1rem;">Save your AI configuration for future use</div>
                                                    
                                                    <div class="ai-persistence-buttons" style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                                                        <button type="button" class="terminal-button" onclick="saveAISettings()" style="font-size: 0.75rem; padding: 0.25rem 0.5rem;" title="Save current settings when AI Enhancement is enabled">
                                                            💾 Save Current Settings
                                                        </button>
                                                        <button type="button" class="terminal-button" onclick="loadAISettings()" style="font-size: 0.75rem; padding: 0.25rem 0.5rem;" title="Load your previously saved settings from disk">
                                                            📂 Load Settings
                                                        </button>
                                                        <button type="button" class="terminal-button" onclick="clearSavedAISettings()" style="font-size: 0.75rem; padding: 0.25rem 0.5rem;" title="Delete all saved settings from disk">
                                                            🗑️ Clear Saved
                                                        </button>
                                                        <button type="button" class="terminal-button" onclick="makeAISettingsPermanent()" style="font-size: 0.75rem; padding: 0.25rem 0.5rem;" title="Save all settings permanently, even if AI Enhancement is disabled">
                                                            📌 Save All Permanently
                                                        </button>
                                                    </div>
                                                </div>
                                                
                                            </div>
                                        </div>
                                    </div>
                                    <!-- End of Full-width Options Layout -->
                                        
                                        <!-- Single Page Save Settings -->
                                        <div class="config-section-divider"></div>
                                        <div class="config-item save-settings-section">
                                            {{ single_page_save_settings_toggle | safe }}
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="config-panel-header" onclick="toggleMultiPageConfig()" id="multiPageHeader" style="display: block;">
                                <label class="input-label config-toggle">
                                    <span class="config-icon">⚙️</span>
                                    MULTI_PAGE_CONFIG
                                    <span class="expand-icon expanded" id="configExpandIcon">▲</span>
                                </label>
                            </div>
                            <div id="multiPageConfig" class="config-panel">
                                <div class="config-grid">
                                    <div class="config-item">
                                        <label class="config-label" for="maxPages">MAX_PAGES_PER_SITE:</label>
                                        <input 
                                            type="number" 
                                            id="maxPages" 
                                            name="maxPages" 
                                            class="terminal-input config-input"
                                            value="50"
                                            min="1"
                                            max="500"
                                            placeholder="50" />
                                        <div class="config-desc">Maximum pages to scrape per website</div>
                                    </div>
                                    
                                    <div class="config-item">
                                        <label class="config-label" for="crawlDepth">CRAWL_DEPTH:</label>
                                        <input 
                                            type="range" 
                                            id="crawlDepth" 
                                            name="crawlDepth" 
                                            class="terminal-slider"
                                            value="2"
                                            min="1"
                                            max="5" />
                                        <div class="slider-value">Depth: <span id="depthValue">2</span></div>
                                        <div class="config-desc">How deep to follow page links</div>
                                    </div>
                                    
                                    <div class="config-item">
                                        <label class="config-label" for="includePatterns">INCLUDE_PATTERNS:</label>
                                        <input 
                                            type="text" 
                                            id="includePatterns" 
                                            name="includePatterns" 
                                            class="terminal-input config-input"
                                            placeholder="menu,food,restaurant"
                                            value="menu,food,restaurant" />
                                        <div class="config-desc">URL patterns to include (comma-separated)</div>
                                    </div>
                                    
                                    <div class="config-item">
                                        <label class="config-label" for="excludePatterns">EXCLUDE_PATTERNS:</label>
                                        <input 
                                            type="text" 
                                            id="excludePatterns" 
                                            name="excludePatterns" 
                                            class="terminal-input config-input"
                                            placeholder="admin,login,cart"
                                            value="admin,login,cart" />
                                        <div class="config-desc">URL patterns to exclude (comma-separated)</div>
                                    </div>
                                    
                                    <div class="config-item">
                                        <label class="config-label" for="rateLimit">RATE_LIMIT_MS:</label>
                                        <input 
                                            type="range" 
                                            id="rateLimit" 
                                            name="rateLimit" 
                                            class="terminal-slider"
                                            value="1000"
                                            min="100"
                                            max="5000"
                                            step="100" />
                                        <div class="slider-value">Delay: <span id="rateLimitValue">1000ms</span></div>
                                        <div class="config-desc">Delay between requests (ethical scraping)</div>
                                    </div>
                                    
                                    <div class="config-item">
                                        <label class="config-label">
                                            <input 
                                                type="checkbox" 
                                                id="enableJavaScript" 
                                                name="enableJavaScript" 
                                                class="terminal-checkbox" />
                                            ENABLE_JAVASCRIPT_RENDERING
                                        </label>
                                        <div class="config-desc">Enable JavaScript rendering for dynamic content (Phase 4.1A)</div>
                                    </div>
                                    
                                    <div class="config-item">
                                        <label class="config-label" for="jsTimeout">JS_TIMEOUT_SECONDS:</label>
                                        <input 
                                            type="range" 
                                            id="jsTimeout" 
                                            name="jsTimeout" 
                                            class="terminal-slider"
                                            value="30"
                                            min="10"
                                            max="120"
                                            step="10" />
                                        <div class="slider-value">Timeout: <span id="jsTimeoutValue">30s</span></div>
                                        <div class="config-desc">Maximum time to wait for JavaScript content</div>
                                    </div>
                                    
                                    <div class="config-item">
                                        <label class="config-label">
                                            <input 
                                                type="checkbox" 
                                                id="enablePopupHandling" 
                                                name="enablePopupHandling" 
                                                class="terminal-checkbox" 
                                                checked />
                                            ENABLE_POPUP_HANDLING
                                        </label>
                                        <div class="config-desc">Auto-handle restaurant popups (age verification, location, etc.)</div>
                                    </div>
                                    
                                    <!-- Advanced Options Section -->
                                    <div class="config-section-divider"></div>
                                    
                                    <!-- Full-width Options Layout -->
                                    <div class="options-layout-container">
                                        <!-- Advanced Options -->
                                        <div class="advanced-options-section">
                                            <div class="config-item advanced-options-header">
                                                <div class="config-toggle-header" onclick="toggleAdvancedOptions()">
                                                    <span class="config-label">🔧 ADVANCED_OPTIONS</span>
                                                    <span class="expand-icon" id="advancedOptionsIcon">▼</span>
                                                </div>
                                            </div>
                                    
                                    <div id="advancedOptionsPanel" class="advanced-options-panel collapsed">
                                        <!-- Page Discovery Toggle -->
                                        <div class="config-item">
                                            <label class="config-label toggle-switch-label">
                                                <input 
                                                    type="checkbox" 
                                                    id="pageDiscoveryEnabled" 
                                                    name="pageDiscoveryEnabled" 
                                                    class="terminal-checkbox toggle-switch" 
                                                    checked />
                                                <span class="toggle-slider"></span>
                                                ENABLE_PAGE_DISCOVERY
                                            </label>
                                            <div class="config-desc">Automatically discover and crawl linked pages beyond explicit URLs</div>
                                            <div class="config-warning" id="pageDiscoveryWarning" style="display: none;">
                                                ⚠️ REDUCED_FUNCTIONALITY // Only explicitly provided URLs will be processed
                                            </div>
                                        </div>
                                        
                                        <!-- Request Timeout -->
                                        <div class="config-item">
                                            <label class="config-label" for="requestTimeout">REQUEST_TIMEOUT_SECONDS:</label>
                                            <input 
                                                type="number" 
                                                id="requestTimeout" 
                                                name="requestTimeout" 
                                                class="terminal-input config-input"
                                                value="30"
                                                min="5"
                                                max="300"
                                                step="5" />
                                            <div class="config-range-indicator">Range: 5-300 seconds</div>
                                            <div class="config-desc">Maximum time to wait for each page request</div>
                                            <div class="validation-error" id="timeoutValidationError" style="display: none;"></div>
                                        </div>
                                        
                                        <!-- Concurrent Requests -->
                                        <div class="config-item">
                                            <label class="config-label" for="concurrentRequests">CONCURRENT_REQUESTS:</label>
                                            <input 
                                                type="range" 
                                                id="concurrentRequests" 
                                                name="concurrentRequests" 
                                                class="terminal-slider"
                                                value="5"
                                                min="1"
                                                max="10"
                                                step="1" />
                                            <div class="slider-value">Concurrent: <span id="concurrentRequestsValue">5</span></div>
                                            <div class="config-desc">Number of simultaneous requests (be respectful to servers)</div>
                                        </div>
                                        
                                        <!-- Follow Redirects -->
                                        <div class="config-item">
                                            <label class="config-label">
                                                <input 
                                                    type="checkbox" 
                                                    id="followRedirects" 
                                                    name="followRedirects" 
                                                    class="terminal-checkbox" 
                                                    checked />
                                                FOLLOW_REDIRECTS
                                            </label>
                                            <div class="config-desc">Automatically follow HTTP redirects (301, 302, etc.)</div>
                                        </div>
                                        
                                        <!-- Respect Robots.txt -->
                                        <div class="config-item">
                                            <label class="config-label">
                                                <input 
                                                    type="checkbox" 
                                                    id="respectRobotsTxt" 
                                                    name="respectRobotsTxt" 
                                                    class="terminal-checkbox" 
                                                    checked />
                                                RESPECT_ROBOTS_TXT
                                            </label>
                                            <div class="config-desc">Check and respect robots.txt rules (ethical scraping)</div>
                                        </div>
                                        
                                        <!-- Reset Button -->
                                        <div class="config-item reset-section">
                                            <button type="button" 
                                                    class="reset-defaults-btn" 
                                                    onclick="resetAdvancedOptionsToDefaults()">
                                                🔄 RESET_TO_DEFAULTS
                                            </button>
                                        </div>
                                            </div>
                                        </div>
                                        
                                        <!-- AI Enhancement Options -->
                                        <div class="ai-enhancement-section">
                                            <div class="config-item ai-enhancement-header">
                                                <div class="config-toggle-header" onclick="toggleAIEnhancementOptions()">
                                                    <span class="config-label">🤖 AI_ENHANCEMENT_OPTIONS</span>
                                                    <span class="expand-icon" id="aiEnhancementIcon">▼</span>
                                                </div>
                                            </div>
                                            
                                            <div id="aiEnhancementPanel" class="ai-enhancement-panel collapsed">
                                            <!-- Enable AI Enhancement Toggle -->
                                            <div class="config-item">
                                                <label class="config-label toggle-switch-label">
                                                    <input 
                                                        type="checkbox" 
                                                        id="aiEnhancementEnabled" 
                                                        name="aiEnhancementEnabled" 
                                                        class="terminal-checkbox toggle-switch" 
                                                        onchange="handleAIEnhancementToggle()" />
                                                    <span class="toggle-slider"></span>
                                                    ENABLE_AI_ENHANCEMENT
                                                </label>
                                                <div class="config-desc">Enable AI-powered content analysis and extraction enhancement (optional)</div>
                                                <div class="config-warning" style="color: var(--accent-amber); font-size: 0.75rem; margin-top: 0.25rem;">
                                                    ⚠️ AI features are completely optional. Traditional extraction works without AI.
                                                </div>
                                            </div>
                                            
                                            <!-- AI Configuration Options (hidden by default) -->
                                            <div id="aiConfigOptions" class="ai-config-options collapsed">
                                                
                                                <!-- LLM Provider Selection -->
                                                <div class="config-item">
                                                    <label class="config-label" for="llmProvider">LLM_PROVIDER:</label>
                                                    <select id="llmProvider" name="llmProvider" class="terminal-input config-input" onchange="handleProviderChange()">
                                                        <option value="openai">OpenAI GPT</option>
                                                        <option value="claude">Anthropic Claude</option>
                                                        <option value="ollama">Ollama (Local)</option>
                                                        <option value="llama_cpp">llama.cpp (Local)</option>
                                                        <option value="custom">Custom OpenAI-Compatible</option>
                                                    </select>
                                                    <div class="config-desc">Choose your preferred AI language model provider</div>
                                                </div>
                                                
                                                <!-- Model Selection Dropdown -->
                                                <div class="config-item" id="modelSection" style="display: none;">
                                                    <label class="config-label" for="modelSelect">MODEL:</label>
                                                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                                                        <select id="modelSelect" name="modelSelect" class="terminal-input config-input" style="flex: 1;">
                                                            <option value="">Select model...</option>
                                                        </select>
                                                        <button type="button" 
                                                                id="refreshModelsButton"
                                                                class="terminal-button"
                                                                onclick="refreshModels()"
                                                                style="padding: 0.25rem 0.5rem; font-size: 0.8rem;"
                                                                title="Refresh available models">
                                                            🔄
                                                        </button>
                                                    </div>
                                                    <div class="config-desc">Choose specific model for selected provider</div>
                                                    <div class="config-warning" style="display: none;" id="modelWarning">
                                                        ⚠️ Model selection error
                                                    </div>
                                                </div>
                                                
                                                <!-- API Key Input (for external providers) -->
                                                <div class="config-item" id="apiKeySection">
                                                    <label class="config-label" for="aiApiKey">API_KEY:</label>
                                                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                                                        <input 
                                                            type="password" 
                                                            id="aiApiKey" 
                                                            name="aiApiKey" 
                                                            class="terminal-input config-input"
                                                            placeholder="Enter API Key (any format accepted)"
                                                            style="flex: 1;"
                                                            autocomplete="off"
                                                            oninput="handleApiKeyInput('multi')"
                                                        />
                                                        <button type="button" 
                                                                id="toggleApiKeyVisibility"
                                                                class="terminal-button"
                                                                onclick="toggleApiKeyVisibility()"
                                                                style="padding: 0.25rem 0.5rem; font-size: 0.8rem;"
                                                                title="Toggle API key visibility">
                                                            👁️
                                                        </button>
                                                    </div>
                                                    <div class="config-desc">API key for external AI services (stored securely, optional)</div>
                                                    <div class="config-warning" style="display: none;" id="apiKeyWarning">
                                                        ⚠️ Invalid API key format
                                                    </div>
                                                </div>
                                                
                                                <!-- Custom Provider Configuration -->
                                                <div class="config-item" id="customProviderSection" style="display: none;">
                                                    <label class="config-label">CUSTOM_PROVIDER_CONFIG:</label>
                                                    
                                                    <div class="config-subitem">
                                                        <label class="config-label" for="customProviderName">Provider Name:</label>
                                                        <input 
                                                            type="text" 
                                                            id="customProviderName" 
                                                            name="customProviderName" 
                                                            class="terminal-input config-input"
                                                            placeholder="e.g., My Local LLM"
                                                            style="margin-bottom: 0.5rem;" />
                                                    </div>
                                                    
                                                    <div class="config-subitem">
                                                        <label class="config-label" for="customBaseUrl">Base URL:</label>
                                                        <input 
                                                            type="text" 
                                                            id="customBaseUrl" 
                                                            name="customBaseUrl" 
                                                            class="terminal-input config-input"
                                                            placeholder="https://my-llm.com/v1"
                                                            style="margin-bottom: 0.5rem;" />
                                                    </div>
                                                    
                                                    <div class="config-subitem">
                                                        <label class="config-label" for="customModelName">Model Name:</label>
                                                        <input 
                                                            type="text" 
                                                            id="customModelName" 
                                                            name="customModelName" 
                                                            class="terminal-input config-input"
                                                            placeholder="gpt-3.5-turbo"
                                                            style="margin-bottom: 0.5rem;" />
                                                    </div>
                                                    
                                                    <div class="config-desc">Configure custom OpenAI-compatible endpoint</div>
                                                </div>
                                                
                                                <!-- Local Service Status (for local providers) -->
                                                <div class="config-item" id="localServiceStatus" style="display: none;">
                                                    <div class="config-label">SERVICE_STATUS:</div>
                                                    <div id="serviceStatusIndicator" class="service-status">
                                                        <span class="status-dot" id="statusDot"></span>
                                                        <span id="statusText">Checking connection...</span>
                                                    </div>
                                                    <div class="config-desc">Connection status to local AI service</div>
                                                </div>
                                                
                                                <!-- AI Feature Toggles -->
                                                <div class="config-item">
                                                    <div class="config-label">AI_FEATURES:</div>
                                                    <div class="feature-toggles-grid">
                                                        <label class="feature-toggle">
                                                            <input type="checkbox" id="nutritionalAnalysis" name="nutritionalAnalysis" checked class="terminal-checkbox" />
                                                            <span class="feature-name">Nutritional Analysis</span>
                                                        </label>
                                                        <label class="feature-toggle">
                                                            <input type="checkbox" id="priceAnalysis" name="priceAnalysis" checked class="terminal-checkbox" />
                                                            <span class="feature-name">Price Analysis</span>
                                                        </label>
                                                        <label class="feature-toggle">
                                                            <input type="checkbox" id="cuisineClassification" name="cuisineClassification" checked class="terminal-checkbox" />
                                                            <span class="feature-name">Cuisine Classification</span>
                                                        </label>
                                                        <label class="feature-toggle">
                                                            <input type="checkbox" id="multimodalAnalysis" name="multimodalAnalysis" class="terminal-checkbox" />
                                                            <span class="feature-name">Multi-modal Analysis</span>
                                                        </label>
                                                        <label class="feature-toggle">
                                                            <input type="checkbox" id="patternLearning" name="patternLearning" class="terminal-checkbox" />
                                                            <span class="feature-name">Pattern Learning</span>
                                                        </label>
                                                        <label class="feature-toggle">
                                                            <input type="checkbox" id="dynamicPrompts" name="dynamicPrompts" class="terminal-checkbox" />
                                                            <span class="feature-name">Dynamic Prompts</span>
                                                        </label>
                                                    </div>
                                                    <div class="config-desc">Select which AI-powered analysis features to enable</div>
                                                </div>
                                                
                                                <!-- Confidence Threshold Slider -->
                                                <div class="config-item">
                                                    <label class="config-label" for="confidenceThreshold">CONFIDENCE_THRESHOLD:</label>
                                                    <input 
                                                        type="range" 
                                                        id="confidenceThreshold" 
                                                        name="confidenceThreshold" 
                                                        class="terminal-slider"
                                                        value="0.7"
                                                        min="0.1"
                                                        max="1.0"
                                                        step="0.1" 
                                                        oninput="updateConfidenceValue(this.value)" />
                                                    <div class="slider-value">Threshold: <span id="confidenceValue">0.7</span></div>
                                                    <div class="config-desc">Minimum confidence required for AI predictions (lower = more results, higher = more accurate)</div>
                                                </div>
                                                
                                                <!-- Custom Questions -->
                                                <div class="config-item">
                                                    <label class="config-label" for="customQuestions">CUSTOM_QUESTIONS:</label>
                                                    <textarea 
                                                        id="customQuestions" 
                                                        name="customQuestions" 
                                                        class="terminal-input"
                                                        placeholder="Enter questions (one per line, max 200 chars each)&#10;Example: Are takeout containers eco-friendly?&#10;Example: What's the wifi password policy?"
                                                        rows="3"
                                                        style="width: 100%; resize: vertical; font-family: 'Courier New', monospace;"
                                                        oninput="validateCustomQuestions('multi')"
                                                    ></textarea>
                                                    <div class="config-desc" id="customQuestionsDesc">Add custom questions for AI to answer (200 char limit per question)</div>
                                                </div>
                                                
                                                <!-- AI Settings Persistence Controls -->
                                                <div class="config-section-divider"></div>
                                                <div class="config-item">
                                                    <div class="config-label">🔒 AI_SETTINGS_PERSISTENCE</div>
                                                    <div class="config-desc" style="margin-bottom: 1rem;">Save your AI configuration for future use</div>
                                                    
                                                    <div class="ai-persistence-buttons" style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                                                        <button type="button" class="terminal-button" onclick="saveAISettings()" style="font-size: 0.75rem; padding: 0.25rem 0.5rem;" title="Save current settings when AI Enhancement is enabled">
                                                            💾 Save Current Settings
                                                        </button>
                                                        <button type="button" class="terminal-button" onclick="loadAISettings()" style="font-size: 0.75rem; padding: 0.25rem 0.5rem;" title="Load your previously saved settings from disk">
                                                            📂 Load Settings
                                                        </button>
                                                        <button type="button" class="terminal-button" onclick="clearSavedAISettings()" style="font-size: 0.75rem; padding: 0.25rem 0.5rem;" title="Delete all saved settings from disk">
                                                            🗑️ Clear Saved
                                                        </button>
                                                        <button type="button" class="terminal-button" onclick="makeAISettingsPermanent()" style="font-size: 0.75rem; padding: 0.25rem 0.5rem;" title="Save all settings permanently, even if AI Enhancement is disabled">
                                                            📌 Save All Permanently
                                                        </button>
                                                    </div>
                                                </div>
                                                
                                            </div>
                                        </div>
                                        
                                        <!-- Reset Button -->
                                        <div class="config-item reset-section">
                                            <button type="button" 
                                                    class="reset-defaults-btn" 
                                                    onclick="resetAdvancedOptionsToDefaults()">
                                                🔄 RESET_TO_DEFAULTS
                                            </button>
                                            </div>
                                        </div>
                                    </div>
                                    <!-- End of Full-width Options Layout -->
                                </div>
                                
                                <!-- Multi Page Save Settings -->
                                <div class="config-section-divider"></div>
                                <div class="config-item save-settings-section">
                                    {{ multi_page_save_settings_toggle | safe }}
                                </div>
                            </div>
                        </div>
                        
                        <div class="input-group">
                            <label class="input-label" for="fileMode">AGGREGATION_MODE:</label>
                            <select id="fileMode" name="fileMode" class="terminal-input">
                                <option value="single">UNIFIED // Single file for all targets</option>
                                <option value="multiple">SEGMENTED // Individual files per target</option>
                            </select>
                        </div>
                        
                        <div class="input-group">
                            <label class="input-label">OUTPUT_FORMAT:</label>
                            <div class="format-grid">
                                <label class="format-option" data-format="text">
                                    <input type="radio" id="fileFormatText" name="fileFormat" value="text">
                                    <div class="format-title">TEXT</div>
                                    <div class="format-desc">Raw structured data for RAG ingestion</div>
                                </label>
                                <label class="format-option" data-format="pdf">
                                    <input type="radio" id="fileFormatPdf" name="fileFormat" value="pdf">
                                    <div class="format-title">PDF</div>
                                    <div class="format-desc">Formatted document for human review</div>
                                </label>
                                <label class="format-option selected" data-format="json">
                                    <input type="radio" id="fileFormatJson" name="fileFormat" value="json" checked>
                                    <div class="format-title">JSON</div>
                                    <div class="format-desc">Structured data for system integration</div>
                                </label>
                            </div>
                        </div>
                        
                        <div id="jsonFieldSelection" class="input-group" style="display: block;">
                            <label class="input-label">JSON_FIELD_SELECTION:</label>
                            <div class="field-selection-grid">
                                <label class="field-option">
                                    <input type="checkbox" name="jsonFields" value="core_fields" checked>
                                    <div class="field-title">CORE FIELDS</div>
                                    <div class="field-desc">Name, address, phone, hours</div>
                                </label>
                                <label class="field-option">
                                    <input type="checkbox" name="jsonFields" value="extended_fields" checked>
                                    <div class="field-title">EXTENDED FIELDS</div>
                                    <div class="field-desc">Cuisine, features, parking</div>
                                </label>
                                <label class="field-option">
                                    <input type="checkbox" name="jsonFields" value="contact_fields" checked>
                                    <div class="field-title">CONTACT FIELDS</div>
                                    <div class="field-desc">Email, social media, delivery</div>
                                </label>
                                <label class="field-option">
                                    <input type="checkbox" name="jsonFields" value="descriptive_fields" checked>
                                    <div class="field-title">DESCRIPTIVE FIELDS</div>
                                    <div class="field-desc">Ambiance, dietary options</div>
                                </label>
                            </div>
                        </div>
                    </form>
                </div>
                
                <div id="progressContainer" class="terminal-output">
                    <div class="progress-bar">
                        <div id="progressFill" class="progress-fill"></div>
                    </div>
                    <div id="progressText">INITIALIZING_EXTRACTION_SEQUENCE...</div>
                    <div id="currentUrl"></div>
                    <div id="timeEstimate"></div>
                    <div id="memoryUsage"></div>
                    
                    <!-- Enhanced Real-Time Progress Visualization -->
                    <div id="realTimeProgress" class="real-time-progress" style="display: none;">
                        <div class="currently-processing">
                            <span class="label">Currently Processing:</span>
                            <span id="currentPageUrl" class="current-url pulsing"></span>
                        </div>
                        
                        <div class="queue-status">
                            <div class="queue-metrics">
                                <div class="metric">
                                    <span class="metric-label">Completed:</span>
                                    <span id="pagesCompleted" class="metric-value">0</span>
                                </div>
                                <div class="metric">
                                    <span class="metric-label">In Queue:</span>
                                    <span id="pagesInQueue" class="metric-value">0</span>
                                </div>
                                <div class="metric">
                                    <span class="metric-label">Remaining:</span>
                                    <span id="pagesRemaining" class="metric-value">0</span>
                                </div>
                                <div class="metric">
                                    <span class="metric-label">Processing:</span>
                                    <span id="currentlyProcessing" class="metric-value">0</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="time-estimates">
                            <div class="estimate">
                                <span class="estimate-label">Estimated Remaining:</span>
                                <span id="estimatedTimeRemaining" class="estimate-value">~0s</span>
                            </div>
                            <div class="estimate">
                                <span class="estimate-label">Average Time:</span>
                                <span id="averageProcessingTime" class="estimate-value">0s</span>
                            </div>
                        </div>
                        
                        <div id="discoveryNotifications" class="discovery-notifications">
                            <!-- Discovery notifications will appear here -->
                        </div>
                    </div>
                </div>
            </div>
            
            <script>
                // Terminal UI Elements
                const form = document.getElementById('scrapeForm');
                const urlsInput = document.getElementById('urls');
                const submitBtn = document.getElementById('submitBtn');
                const validateBtn = document.getElementById('validateBtn');
                const clearBtn = document.getElementById('clearBtn');
                
                // Debug: Check if elements were found
                console.log('DOM Elements found:');
                console.log('form:', form);
                console.log('urlsInput:', urlsInput);
                console.log('submitBtn:', submitBtn);
                const progressContainer = document.getElementById('progressContainer');
                const progressFill = document.getElementById('progressFill');
                const progressText = document.getElementById('progressText');
                const currentUrl = document.getElementById('currentUrl');
                const timeEstimate = document.getElementById('timeEstimate');
                const memoryUsage = document.getElementById('memoryUsage');
                const resultsContainer = document.getElementById('resultsContainer');
                const resultsContent = document.getElementById('resultsContent');
                const noResults = document.getElementById('noResults');
                const sitesResults = document.getElementById('sitesResults');
                const urlValidation = document.getElementById('urlValidation');
                const statusBar = document.querySelector('.status-bar');
                const formatOptions = document.querySelectorAll('.format-option');
                const dataFlow = document.querySelector('.data-flow');
                
                // Real-time progress elements
                const realTimeProgress = document.getElementById('realTimeProgress');
                const currentPageUrl = document.getElementById('currentPageUrl');
                const pagesCompleted = document.getElementById('pagesCompleted');
                const pagesInQueue = document.getElementById('pagesInQueue');
                const pagesRemaining = document.getElementById('pagesRemaining');
                const currentlyProcessing = document.getElementById('currentlyProcessing');
                const estimatedTimeRemaining = document.getElementById('estimatedTimeRemaining');
                const averageProcessingTime = document.getElementById('averageProcessingTime');
                const discoveryNotifications = document.getElementById('discoveryNotifications');
                
                let progressInterval;
                let terminalEffects = true;

                // Initialize terminal effects
                document.addEventListener('DOMContentLoaded', function() {
                    initializeTerminalEffects();
                    setupFormatSelection();
                    setupSliderUpdates();
                    setupModeSelection();
                    
                    // Force dropdown styling
                    forceDropdownStyling();
                    
                    // Initialize help text to be hidden
                    initializeHelpText();
                    
                    // Automatically load saved AI settings on page load
                    console.log('Page loaded - attempting to load AI settings...');
                    loadAISettings();
                });
                
                function initializeHelpText() {
                    const schemaHelpStatic = document.getElementById('schema-type-help-static');
                    if (schemaHelpStatic) {
                        const helpContent = schemaHelpStatic.querySelector('.help-content');
                        const toggleArrow = schemaHelpStatic.querySelector('.toggle-help');
                        
                        if (helpContent && toggleArrow) {
                            helpContent.style.display = 'none'; // Force hidden with inline style
                            helpContent.classList.add('hidden');
                            helpContent.classList.remove('visible');
                            toggleArrow.textContent = '▶';
                        }
                    }
                }

                function forceDropdownStyling() {
                    // Force all select elements to have dark background
                    const selects = document.querySelectorAll('select.terminal-input');
                    
                    selects.forEach(select => {
                        // Apply inline styles to override any browser defaults
                        select.style.cssText = `
                            background: #1a1a1a !important;
                            background-color: #1a1a1a !important;
                            color: #ffffff !important;
                            -webkit-appearance: none !important;
                            -moz-appearance: none !important;
                            appearance: none !important;
                        `;
                        
                        // Re-apply styles on focus/blur
                        select.addEventListener('focus', function() {
                            this.style.backgroundColor = '#1a1a1a';
                            this.style.color = '#ffffff';
                        });
                        
                        select.addEventListener('blur', function() {
                            this.style.backgroundColor = '#1a1a1a';
                            this.style.color = '#ffffff';
                        });
                    });
                    
                    // Use MutationObserver to catch any dynamic style changes
                    const observer = new MutationObserver(function(mutations) {
                        mutations.forEach(function(mutation) {
                            if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
                                const target = mutation.target;
                                if (target.tagName === 'SELECT' && target.classList.contains('terminal-input')) {
                                    if (target.style.backgroundColor !== '#1a1a1a') {
                                        target.style.backgroundColor = '#1a1a1a';
                                        target.style.color = '#ffffff';
                                    }
                                }
                            }
                        });
                    });
                    
                    // Observe all select elements
                    selects.forEach(select => {
                        observer.observe(select, { attributes: true, attributeFilter: ['style'] });
                    });
                    
                    // Apply fixes again after a delay to catch any async changes
                    setTimeout(() => {
                        selects.forEach(select => {
                            select.style.backgroundColor = '#1a1a1a';
                            select.style.color = '#ffffff';
                        });
                    }, 100);
                    
                    setTimeout(() => {
                        selects.forEach(select => {
                            select.style.backgroundColor = '#1a1a1a';
                            select.style.color = '#ffffff';
                        });
                    }, 500);
                }

                function initializeTerminalEffects() {
                    // Create matrix background effect
                    createMatrixEffect();
                    
                    // Add terminal cursor effect to inputs
                    addTerminalCursorEffect();
                    
                    // Initialize status updates
                    updateSystemStatus('SYSTEM_READY // AWAITING_TARGET_URLs');
                }

                function createMatrixEffect() {
                    const matrixBg = document.querySelector('.matrix-bg');
                    const chars = '01';
                    const columns = Math.floor(window.innerWidth / 20);
                    
                    for (let i = 0; i < 50; i++) {
                        const char = document.createElement('div');
                        char.textContent = chars[Math.floor(Math.random() * chars.length)];
                        char.style.position = 'absolute';
                        char.style.left = Math.random() * 100 + '%';
                        char.style.top = Math.random() * 100 + '%';
                        char.style.color = 'rgba(0, 255, 136, 0.1)';
                        char.style.fontSize = '12px';
                        char.style.fontFamily = 'JetBrains Mono, monospace';
                        char.style.animation = `float ${3 + Math.random() * 4}s ease-in-out infinite`;
                        matrixBg.appendChild(char);
                    }
                }

                function addTerminalCursorEffect() {
                    const inputs = document.querySelectorAll('.terminal-input');
                    inputs.forEach(input => {
                        input.addEventListener('focus', function() {
                            this.style.animation = 'terminal-cursor 1s ease-in-out infinite';
                        });
                        input.addEventListener('blur', function() {
                            this.style.animation = 'none';
                        });
                    });
                }

                function setupFormatSelection() {
                    const jsonFieldSelection = document.getElementById('jsonFieldSelection');
                    
                    formatOptions.forEach(option => {
                        option.addEventListener('click', function() {
                            formatOptions.forEach(opt => opt.classList.remove('selected'));
                            this.classList.add('selected');
                            const radio = this.querySelector('input[type="radio"]');
                            radio.checked = true;
                            
                            // Show/hide JSON field selection based on format choice
                            if (radio.value === 'json') {
                                jsonFieldSelection.style.display = 'block';
                                updateSystemStatus(`JSON_FORMAT_SELECTED // FIELD_CUSTOMIZATION_AVAILABLE`);
                            } else {
                                jsonFieldSelection.style.display = 'none';
                                updateSystemStatus(`FORMAT_SELECTED // ${radio.value.toUpperCase()}_MODE_ACTIVE`);
                            }
                        });
                    });
                }

                // Multi-Page Configuration Panel Functions
                function toggleMultiPageConfig() {
                    const configPanel = document.getElementById('multiPageConfig');
                    const expandIcon = document.getElementById('configExpandIcon');
                    
                    if (configPanel.classList.contains('collapsed')) {
                        configPanel.classList.remove('collapsed');
                        expandIcon.classList.add('expanded');
                        updateSystemStatus('MULTI_PAGE_CONFIG // PANEL_EXPANDED');
                    } else {
                        configPanel.classList.add('collapsed');
                        expandIcon.classList.remove('expanded');
                        updateSystemStatus('MULTI_PAGE_CONFIG // PANEL_COLLAPSED');
                    }
                }

                function toggleAdvancedOptions() {
                    const advancedPanel = document.getElementById('advancedOptionsPanel');
                    const expandIcon = document.getElementById('advancedOptionsIcon');
                    
                    if (!advancedPanel || !expandIcon) {
                        console.error('Advanced Options elements not found:', {advancedPanel, expandIcon});
                        return;
                    }
                    
                    const isCollapsed = advancedPanel.classList.contains('collapsed');
                    
                    if (isCollapsed) {
                        advancedPanel.classList.remove('collapsed');
                        expandIcon.classList.add('expanded');
                        expandIcon.textContent = '▲';
                        updateSystemStatus('ADVANCED_OPTIONS // PANEL_EXPANDED');
                    } else {
                        advancedPanel.classList.add('collapsed');
                        expandIcon.classList.remove('expanded');
                        expandIcon.textContent = '▼';
                        updateSystemStatus('ADVANCED_OPTIONS // PANEL_COLLAPSED');
                    }
                }

                function resetAdvancedOptionsToDefaults() {
                    // Reset all advanced options to their default values
                    document.getElementById('pageDiscoveryEnabled').checked = true;
                    document.getElementById('requestTimeout').value = 30;
                    document.getElementById('concurrentRequests').value = 5;
                    document.getElementById('followRedirects').checked = true;
                    document.getElementById('respectRobotsTxt').checked = true;
                    
                    // Update display values
                    updateConcurrentRequestsDisplay();
                    togglePageDiscoveryWarning();
                    validateAdvancedOptions();
                    
                    updateSystemStatus('ADVANCED_OPTIONS // RESET_TO_DEFAULTS_COMPLETE');
                    showTerminalAlert('SUCCESS: Advanced options reset to default values.');
                }

                function validateAdvancedOptions() {
                    const timeout = parseInt(document.getElementById('requestTimeout').value);
                    const timeoutError = document.getElementById('timeoutValidationError');
                    let isValid = true;
                    
                    // Validate timeout
                    if (timeout < 5 || timeout > 300) {
                        timeoutError.textContent = 'ERROR: Timeout must be between 5 and 300 seconds';
                        timeoutError.style.display = 'block';
                        isValid = false;
                    } else {
                        timeoutError.style.display = 'none';
                    }
                    
                    return isValid;
                }

                function togglePageDiscoveryWarning() {
                    const checkbox = document.getElementById('pageDiscoveryEnabled');
                    const warning = document.getElementById('pageDiscoveryWarning');
                    
                    if (!checkbox.checked) {
                        warning.style.display = 'block';
                        updateSystemStatus('PAGE_DISCOVERY // DISABLED_WARNING_ACTIVE');
                    } else {
                        warning.style.display = 'none';
                        updateSystemStatus('PAGE_DISCOVERY // ENABLED_FULL_FUNCTIONALITY');
                    }
                }

                function updateConcurrentRequestsDisplay() {
                    const slider = document.getElementById('concurrentRequests');
                    const display = document.getElementById('concurrentRequestsValue');
                    if (slider && display) {
                        display.textContent = slider.value;
                    }
                }

                // AI Enhancement Panel Functions
                function toggleAIEnhancementOptions() {
                    const aiPanel = document.getElementById('aiEnhancementPanel');
                    const expandIcon = document.getElementById('aiEnhancementIcon');
                    
                    if (!aiPanel || !expandIcon) {
                        console.error('AI Enhancement elements not found:', {aiPanel, expandIcon});
                        return;
                    }
                    
                    const isCollapsed = aiPanel.classList.contains('collapsed');
                    
                    if (isCollapsed) {
                        aiPanel.classList.remove('collapsed');
                        expandIcon.textContent = '▲';
                        expandIcon.style.transform = 'rotate(180deg)';
                        updateSystemStatus('AI_ENHANCEMENT // PANEL_EXPANDED');
                    } else {
                        aiPanel.classList.add('collapsed');
                        expandIcon.textContent = '▼';
                        expandIcon.style.transform = 'rotate(0deg)';
                        updateSystemStatus('AI_ENHANCEMENT // PANEL_COLLAPSED');
                    }
                }

                function handleAIEnhancementToggle() {
                    const enabledCheckbox = document.getElementById('aiEnhancementEnabled');
                    const configOptions = document.getElementById('aiConfigOptions');
                    
                    if (!enabledCheckbox || !configOptions) {
                        console.error('AI Enhancement toggle elements not found');
                        return;
                    }
                    
                    if (enabledCheckbox.checked) {
                        configOptions.classList.remove('collapsed');
                        updateSystemStatus('AI_ENHANCEMENT // ENABLED_CONFIG_VISIBLE');
                        checkProviderAvailability();
                    } else {
                        configOptions.classList.add('collapsed');
                        updateSystemStatus('AI_ENHANCEMENT // DISABLED_TRADITIONAL_MODE');
                    }
                }

                function handleProviderChange() {
                    const providerSelect = document.getElementById('llmProvider');
                    const apiKeySection = document.getElementById('apiKeySection');
                    const localServiceStatus = document.getElementById('localServiceStatus');
                    const customProviderSection = document.getElementById('customProviderSection');
                    const modelSection = document.getElementById('modelSection');
                    const apiKeyInput = document.getElementById('aiApiKey');
                    
                    if (!providerSelect) return;
                    
                    const selectedProvider = providerSelect.value;
                    
                    // Show/hide sections based on provider
                    if (selectedProvider === 'openai' || selectedProvider === 'claude') {
                        apiKeySection.style.display = 'block';
                        localServiceStatus.style.display = 'none';
                        customProviderSection.style.display = 'none';
                        
                        // Show model selection for OpenAI, hide for others
                        if (selectedProvider === 'openai') {
                            modelSection.style.display = 'block';
                            apiKeyInput.placeholder = 'Enter OpenAI API Key (optional)';
                        } else {
                            modelSection.style.display = 'none';
                            apiKeyInput.placeholder = 'Enter Anthropic API Key (optional)';
                        }
                    } else if (selectedProvider === 'custom') {
                        apiKeySection.style.display = 'block';
                        localServiceStatus.style.display = 'none';
                        customProviderSection.style.display = 'block';
                        modelSection.style.display = 'none';
                        
                        // Update placeholder text for custom provider
                        apiKeyInput.placeholder = 'Enter API Key (any format accepted)';
                    } else {
                        // Local providers (ollama, llama_cpp)
                        apiKeySection.style.display = 'none';
                        localServiceStatus.style.display = 'block';
                        customProviderSection.style.display = 'none';
                        modelSection.style.display = 'none';
                        checkLocalServiceStatus(selectedProvider);
                    }
                    
                    updateSystemStatus(`AI_PROVIDER // ${selectedProvider.toUpperCase()}_SELECTED`);
                }

                function checkProviderAvailability() {
                    const providerSelect = document.getElementById('llmProvider');
                    if (providerSelect) {
                        handleProviderChange(); // Trigger initial provider setup
                    }
                }

                function checkLocalServiceStatus(provider) {
                    const statusDot = document.getElementById('statusDot');
                    const statusText = document.getElementById('statusText');
                    
                    if (!statusDot || !statusText) return;
                    
                    // Set checking state
                    statusDot.className = 'status-dot checking';
                    statusText.textContent = 'Checking connection...';
                    
                    // Simulate checking local service (in real implementation, this would be an API call)
                    setTimeout(() => {
                        if (provider === 'ollama') {
                            // Check if Ollama is available (placeholder - would be real API call)
                            fetch('/api/ai/providers', { credentials: 'same-origin' })
                                .then(response => response.json())
                                .then(data => {
                                    const isAvailable = data.ollama?.available || false;
                                    updateServiceStatus(isAvailable, provider);
                                })
                                .catch(() => {
                                    updateServiceStatus(false, provider);
                                });
                        } else {
                            // For llama_cpp, just show as available (local binary)
                            updateServiceStatus(true, provider);
                        }
                    }, 1000);
                }

                function updateServiceStatus(isAvailable, provider) {
                    const statusDot = document.getElementById('statusDot');
                    const statusText = document.getElementById('statusText');
                    
                    if (!statusDot || !statusText) return;
                    
                    if (isAvailable) {
                        statusDot.className = 'status-dot connected';
                        statusText.textContent = `${provider} service available`;
                        statusText.style.color = 'var(--accent-green)';
                    } else {
                        statusDot.className = 'status-dot disconnected';
                        statusText.textContent = `${provider} service unavailable`;
                        statusText.style.color = 'var(--accent-red)';
                    }
                }

                function updateConfidenceValue(value) {
                    const display = document.getElementById('confidenceValue');
                    if (display) {
                        display.textContent = value;
                    }
                }
                
                function updateSliderValue(sliderId) {
                    const slider = document.getElementById(sliderId);
                    if (!slider) return;
                    
                    const value = slider.value;
                    let displayId;
                    
                    // Map slider IDs to their corresponding display element IDs
                    if (sliderId === 'singleConfidenceThreshold') {
                        displayId = 'singleConfidenceValue';
                    } else if (sliderId === 'confidenceThreshold') {
                        displayId = 'confidenceValue';
                    } else {
                        // Generic fallback: remove 'Threshold' and add 'Value'
                        displayId = sliderId.replace('Threshold', 'Value');
                    }
                    
                    const display = document.getElementById(displayId);
                    if (display) {
                        display.textContent = value;
                    }
                }

                function generateSessionId() {
                    // Generate a unique session ID for this scraping request
                    return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                }

                // Model selection dropdown functions
                async function refreshModels() {
                    const providerSelect = document.getElementById('llmProvider');
                    const apiKeyInput = document.getElementById('aiApiKey');
                    const modelSelect = document.getElementById('modelSelect');
                    const modelWarning = document.getElementById('modelWarning');
                    
                    if (!providerSelect || !apiKeyInput || !modelSelect) return;
                    
                    const provider = providerSelect.value;
                    let apiKey = apiKeyInput.value.trim();
                    
                    // If no typed key but we have a saved key, tell the API to use the saved key
                    const hasSavedKey = apiKeyInput.hasAttribute('data-has-saved-key');
                    const useSavedKey = !apiKey && hasSavedKey;
                    
                    // Clear previous options
                    modelSelect.innerHTML = '<option value="">Loading models...</option>';
                    modelWarning.style.display = 'none';
                    
                    try {
                        const response = await fetch('/api/ai/get-models', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                provider: provider,
                                api_key: apiKey,
                                use_saved_key: useSavedKey
                            })
                        });
                        
                        const data = await response.json();
                        
                        // Clear loading option
                        modelSelect.innerHTML = '<option value="">Select model...</option>';
                        
                        // Check if response indicates an error (even with 400/500 status codes)
                        if (!response.ok && data.error) {
                            modelWarning.textContent = `⚠️ ${data.error}`;
                            modelWarning.style.display = 'block';
                            return;
                        }
                        
                        if (data.success && data.models && data.models.length > 0) {
                            // Populate with available models
                            data.models.forEach(model => {
                                const option = document.createElement('option');
                                option.value = model.id;
                                option.textContent = model.name || model.id;
                                modelSelect.appendChild(option);
                            });
                            
                            // Set default model if specified
                            if (data.default_model) {
                                modelSelect.value = data.default_model;
                            }
                        } else if (!data.implemented) {
                            // Provider not implemented
                            const option = document.createElement('option');
                            option.value = '';
                            option.textContent = 'Not Implemented';
                            option.disabled = true;
                            modelSelect.appendChild(option);
                        } else {
                            // Error occurred
                            modelWarning.textContent = `⚠️ ${data.message || data.error || 'Failed to load models'}`;
                            modelWarning.style.display = 'block';
                        }
                    } catch (error) {
                        console.error('Error fetching models:', error);
                        modelSelect.innerHTML = '<option value="">Error loading models</option>';
                        modelWarning.textContent = '⚠️ Network error loading models';
                        modelWarning.style.display = 'block';
                    }
                }

                async function refreshSingleModels() {
                    const providerSelect = document.getElementById('singleLlmProvider');
                    const apiKeyInput = document.getElementById('singleAiApiKey');
                    const modelSelect = document.getElementById('singleModelSelect');
                    const modelWarning = document.getElementById('singleModelWarning');
                    
                    if (!providerSelect || !apiKeyInput || !modelSelect) return;
                    
                    const provider = providerSelect.value;
                    let apiKey = apiKeyInput.value.trim();
                    
                    // If no typed key but we have a saved key, tell the API to use the saved key
                    const hasSavedKey = apiKeyInput.hasAttribute('data-has-saved-key');
                    const useSavedKey = !apiKey && hasSavedKey;
                    
                    // Clear previous options
                    modelSelect.innerHTML = '<option value="">Loading models...</option>';
                    modelWarning.style.display = 'none';
                    
                    try {
                        const response = await fetch('/api/ai/get-models', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                provider: provider,
                                api_key: apiKey,
                                use_saved_key: useSavedKey
                            })
                        });
                        
                        const data = await response.json();
                        
                        // Clear loading option
                        modelSelect.innerHTML = '<option value="">Select model...</option>';
                        
                        // Check if response indicates an error (even with 400/500 status codes)
                        if (!response.ok && data.error) {
                            modelWarning.textContent = `⚠️ ${data.error}`;
                            modelWarning.style.display = 'block';
                            return;
                        }
                        
                        if (data.success && data.models && data.models.length > 0) {
                            // Populate with available models
                            data.models.forEach(model => {
                                const option = document.createElement('option');
                                option.value = model.id;
                                option.textContent = model.name || model.id;
                                modelSelect.appendChild(option);
                            });
                            
                            // Set default model if specified
                            if (data.default_model) {
                                modelSelect.value = data.default_model;
                            }
                        } else if (!data.implemented) {
                            // Provider not implemented
                            const option = document.createElement('option');
                            option.value = '';
                            option.textContent = 'Not Implemented';
                            option.disabled = true;
                            modelSelect.appendChild(option);
                        } else {
                            // Error occurred
                            modelWarning.textContent = `⚠️ ${data.message || data.error || 'Failed to load models'}`;
                            modelWarning.style.display = 'block';
                        }
                    } catch (error) {
                        console.error('Error fetching models:', error);
                        modelSelect.innerHTML = '<option value="">Error loading models</option>';
                        modelWarning.textContent = '⚠️ Network error loading models';
                        modelWarning.style.display = 'block';
                    }
                }
                
                function getAIConfiguration() {
                    // Check both single-page and multi-page modes
                    const multiPageEnabled = document.getElementById('aiEnhancementEnabled');
                    const singlePageEnabled = document.getElementById('singleAiEnhancementEnabled');
                    
                    // Determine which scraping mode is currently active
                    const scrapingMode = document.querySelector('input[name="scrapingMode"]:checked')?.value || 'multi';
                    
                    // Determine which mode is active and if AI is enabled
                    let isEnabled = false;
                    let activeMode = scrapingMode;
                    
                    if (scrapingMode === 'single' && singlePageEnabled && singlePageEnabled.checked) {
                        isEnabled = true;
                        activeMode = 'single';
                    } else if (scrapingMode === 'multi' && multiPageEnabled && multiPageEnabled.checked) {
                        isEnabled = true;
                        activeMode = 'multi';
                    }
                    
                    // Debug logging
                    console.log('AI Configuration Debug:', {
                        scrapingMode,
                        singlePageEnabled: singlePageEnabled?.checked,
                        multiPageEnabled: multiPageEnabled?.checked,
                        isEnabled,
                        activeMode
                    });
                    
                    if (!isEnabled) {
                        return {
                            ai_enhancement_enabled: false
                        };
                    }
                    
                    // Get configuration from the active mode
                    const prefix = activeMode === 'single' ? 'single' : '';
                    
                    // DEBUG: Log what we're looking for
                    console.log('getAIConfiguration DEBUG:', {
                        activeMode,
                        prefix,
                        lookingForApiKey: `${prefix}AiApiKey`,
                        fallbackApiKey: 'aiApiKey'
                    });
                    
                    // Get API key with proper ID lookup
                    let apiKeyValue = '';
                    if (activeMode === 'single') {
                        // Single mode: look for 'singleAiApiKey'
                        const singleApiKeyElement = document.getElementById('singleAiApiKey');
                        apiKeyValue = singleApiKeyElement?.value || '';
                        console.log('Single mode API key element:', singleApiKeyElement, 'value:', apiKeyValue);
                    } else {
                        // Multi mode: look for 'aiApiKey' 
                        const multiApiKeyElement = document.getElementById('aiApiKey');
                        apiKeyValue = multiApiKeyElement?.value || '';
                        console.log('Multi mode API key element:', multiApiKeyElement, 'value:', apiKeyValue);
                    }
                    
                    return {
                        ai_enhancement_enabled: true,
                        llm_provider: document.getElementById(`${prefix}LlmProvider`)?.value || 
                                     document.getElementById('llmProvider')?.value || 'openai',
                        api_key: apiKeyValue,
                        model: document.getElementById(`${prefix}ModelSelect`)?.value || 
                               document.getElementById('modelSelect')?.value || '',
                        features: {
                            nutritional_analysis: document.getElementById(`${prefix}NutritionalAnalysis`)?.checked || 
                                                  document.getElementById('nutritionalAnalysis')?.checked || false,
                            price_analysis: document.getElementById(`${prefix}PriceAnalysis`)?.checked || 
                                           document.getElementById('priceAnalysis')?.checked || false,
                            cuisine_classification: document.getElementById(`${prefix}CuisineClassification`)?.checked || 
                                                   document.getElementById('cuisineClassification')?.checked || false,
                            multimodal_analysis: document.getElementById(`${prefix}MultimodalAnalysis`)?.checked || 
                                                document.getElementById('multimodalAnalysis')?.checked || false,
                            pattern_learning: document.getElementById(`${prefix}PatternLearning`)?.checked || 
                                             document.getElementById('patternLearning')?.checked || false,
                            dynamic_prompts: document.getElementById(`${prefix}DynamicPrompts`)?.checked || 
                                            document.getElementById('dynamicPrompts')?.checked || false
                        },
                        confidence_threshold: parseFloat(document.getElementById(`${prefix}ConfidenceThreshold`)?.value || 
                                                        document.getElementById('confidenceThreshold')?.value || 0.7),
                        // Custom questions
                        custom_questions: parseCustomQuestions(prefix),
                        // Custom provider fields
                        custom_provider_name: document.getElementById(`${prefix}CustomProviderName`)?.value || 
                                             document.getElementById('customProviderName')?.value || '',
                        custom_base_url: document.getElementById(`${prefix}CustomBaseUrl`)?.value || 
                                        document.getElementById('customBaseUrl')?.value || '',
                        custom_model_name: document.getElementById(`${prefix}CustomModelName`)?.value || 
                                          document.getElementById('customModelName')?.value || '',
                        active_mode: activeMode
                    };
                }

                // AI Settings Persistence Functions
                async function saveAISettings() {
                    try {
                        const settings = getAIConfiguration();
                        console.log('AI Configuration to save:', settings);
                        
                        if (!settings.ai_enhancement_enabled) {
                            showTerminalAlert('No AI settings to save (AI enhancement is disabled)');
                            return;
                        }
                        
                        const url = '/api/ai/save-settings';
                        console.log('Sending request to:', url);
                        console.log('Full URL:', window.location.origin + url);
                        const response = await fetch(url, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            credentials: 'same-origin',
                            body: JSON.stringify({
                                settings: settings
                            })
                        });
                        
                        console.log('Response received:', response);
                        console.log('Response status:', response.status);
                        console.log('Response ok:', response.ok);
                        
                        if (!response.ok) {
                            const errorText = await response.text();
                            console.error('Response error text:', errorText);
                            throw new Error(`HTTP ${response.status}: ${errorText}`);
                        }
                        
                        const data = await response.json();
                        console.log('Response data:', data);
                        
                        if (data.success) {
                            // Configure session with saved settings for immediate use
                            await configureSessionAfterSave(settings);
                            
                            showTerminalAlert('AI settings saved successfully', 'success');
                            updateSystemStatus('AI_SETTINGS // SAVED_TO_PERSISTENT_STORAGE');
                        } else {
                            showTerminalAlert('Failed to save AI settings: ' + data.error, 'error');
                        }
                    } catch (error) {
                        console.error('Error saving AI settings:', error);
                        console.error('Error details:', {
                            name: error.name,
                            message: error.message,
                            stack: error.stack
                        });
                        showTerminalAlert('Error saving AI settings: ' + error.message, 'error');
                    }
                }
                
                function toggleApiKeyVisibility() {
                    const apiKeyInput = document.getElementById('aiApiKey');
                    const toggleButton = document.getElementById('toggleApiKeyVisibility');
                    
                    if (apiKeyInput && toggleButton) {
                        if (apiKeyInput.type === 'password') {
                            apiKeyInput.type = 'text';
                            toggleButton.textContent = '🙈';
                            toggleButton.title = 'Hide API key';
                        } else {
                            apiKeyInput.type = 'password';
                            toggleButton.textContent = '👁️';
                            toggleButton.title = 'Show API key';
                        }
                    }
                }
                
                function toggleSingleApiKeyVisibility() {
                    const apiKeyInput = document.getElementById('singleAiApiKey');
                    const toggleButton = document.getElementById('toggleSingleApiKeyVisibility');
                    
                    if (apiKeyInput && toggleButton) {
                        if (apiKeyInput.type === 'password') {
                            apiKeyInput.type = 'text';
                            toggleButton.textContent = '🙈';
                            toggleButton.title = 'Hide API key';
                        } else {
                            apiKeyInput.type = 'password';
                            toggleButton.textContent = '👁️';
                            toggleButton.title = 'Show API key';
                        }
                    }
                }
                
                function handleApiKeyInput(mode) {
                    const apiKeyInput = document.getElementById(mode === 'single' ? 'singleAiApiKey' : 'aiApiKey');
                    const toggleButton = document.getElementById(mode === 'single' ? 'toggleSingleApiKeyVisibility' : 'toggleApiKeyVisibility');
                    
                    if (apiKeyInput && toggleButton) {
                        // If user types something, re-enable the toggle button
                        if (apiKeyInput.value.length > 0) {
                            toggleButton.disabled = false;
                            toggleButton.style.opacity = '1';
                            toggleButton.style.cursor = 'pointer';
                            toggleButton.title = apiKeyInput.type === 'password' ? 'Show API key' : 'Hide API key';
                        }
                        
                        // Clear the saved key indicator when user types
                        if (apiKeyInput.hasAttribute('data-has-saved-key')) {
                            apiKeyInput.removeAttribute('data-has-saved-key');
                            apiKeyInput.placeholder = 'Enter API Key (any format accepted)';
                        }
                    }
                }
                
                async function loadAISettings() {
                    try {
                        console.log('loadAISettings: Starting to load settings...');
                        const response = await fetch('/api/ai/load-settings', { credentials: 'same-origin' });
                        const data = await response.json();
                        
                        console.log('loadAISettings: API response:', data);
                        
                        if (data.success && data.has_saved_settings) {
                            const settings = data.settings;
                            
                            // Apply settings to UI
                            if (settings.ai_enhancement_enabled) {
                                // Determine currently visible mode, not saved mode
                                const singlePageSection = document.getElementById('singlePageSection');
                                const multiPageSection = document.getElementById('multiPageSection');
                                
                                let currentMode = 'multi'; // default
                                if (singlePageSection && singlePageSection.style.display !== 'none') {
                                    currentMode = 'single';
                                } else if (multiPageSection && multiPageSection.style.display !== 'none') {
                                    currentMode = 'multi';
                                }
                                
                                console.log('loadAISettings: Current UI mode:', currentMode);
                                console.log('loadAISettings: Saved mode was:', settings.active_mode);
                                
                                const activeMode = currentMode;
                                
                                // Enable AI Enhancement (fix element ID)
                                const enabledCheckbox = document.getElementById(activeMode === 'single' ? 'singleAiEnhancementEnabled' : 'aiEnhancementEnabled');
                                if (enabledCheckbox) {
                                    enabledCheckbox.checked = true;
                                    if (activeMode === 'single') {
                                        handleSinglePageAIEnhancementToggle();
                                    } else {
                                        handleAIEnhancementToggle();
                                    }
                                }
                                
                                // Set provider (fix element ID)
                                if (settings.llm_provider) {
                                    const providerSelect = document.getElementById(activeMode === 'single' ? 'singleLlmProvider' : 'llmProvider');
                                    if (providerSelect) {
                                        providerSelect.value = settings.llm_provider;
                                        // Trigger change event to show model dropdown
                                        if (activeMode === 'single') {
                                            handleSinglePageProviderChange();
                                        } else {
                                            handleProviderChange();
                                        }
                                        
                                        // Refresh models and set the saved model after delay
                                        if (settings.model) {
                                            setTimeout(async () => {
                                                if (activeMode === 'single') {
                                                    await refreshSingleModels();
                                                } else {
                                                    await refreshModels();
                                                }
                                                
                                                const modelSelect = document.getElementById(activeMode === 'single' ? 'singleModelSelect' : 'modelSelect');
                                                if (modelSelect) {
                                                    modelSelect.value = settings.model;
                                                }
                                            }, 500);
                                        }
                                    }
                                }
                                
                                // Set confidence threshold
                                if (settings.confidence_threshold) {
                                    const thresholdSlider = document.getElementById(activeMode === 'single' ? 'singleConfidenceThreshold' : 'confidenceThreshold');
                                    if (thresholdSlider) {
                                        thresholdSlider.value = settings.confidence_threshold;
                                        updateSliderValue(activeMode === 'single' ? 'singleConfidenceThreshold' : 'confidenceThreshold');
                                    }
                                }
                                
                                // Set custom questions
                                if (settings.custom_questions && Array.isArray(settings.custom_questions)) {
                                    const questionsField = document.getElementById(activeMode === 'single' ? 'singleCustomQuestions' : 'customQuestions');
                                    if (questionsField) {
                                        questionsField.value = settings.custom_questions.join('\n');
                                        validateCustomQuestions(activeMode);
                                    }
                                }
                                
                                // Set features
                                if (settings.features) {
                                    Object.keys(settings.features).forEach(feature => {
                                        // Convert snake_case to PascalCase for single mode, camelCase for multi mode
                                        const words = feature.split('_');
                                        const featureName = words.map(word => word.charAt(0).toUpperCase() + word.slice(1)).join('');
                                        const camelCaseName = words[0] + words.slice(1).map(word => word.charAt(0).toUpperCase() + word.slice(1)).join('');
                                        
                                        const checkboxId = activeMode === 'single' ? 'single' + featureName : camelCaseName;
                                        const checkbox = document.getElementById(checkboxId);
                                        if (checkbox) {
                                            checkbox.checked = settings.features[feature];
                                        }
                                    });
                                }
                                
                                // Show masked API key if available
                                if (settings.api_key_masked) {
                                    const apiKeyInput = document.getElementById(activeMode === 'single' ? 'singleAiApiKey' : 'aiApiKey');
                                    const toggleButton = document.getElementById(activeMode === 'single' ? 'toggleSingleApiKeyVisibility' : 'toggleApiKeyVisibility');
                                    
                                    if (apiKeyInput) {
                                        apiKeyInput.placeholder = 'Saved: ' + settings.api_key_masked;
                                        // Set a data attribute to indicate saved key exists
                                        apiKeyInput.setAttribute('data-has-saved-key', 'true');
                                    }
                                    
                                    if (toggleButton) {
                                        // Disable toggle button since we can't show the actual saved key
                                        toggleButton.disabled = true;
                                        toggleButton.title = 'Cannot show saved API key for security';
                                        toggleButton.style.opacity = '0.5';
                                        toggleButton.style.cursor = 'not-allowed';
                                    }
                                }
                            }
                            
                            showTerminalAlert('AI settings loaded successfully', 'success');
                            updateSystemStatus('AI_SETTINGS // LOADED_FROM_PERSISTENT_STORAGE');
                            
                            // Auto-refresh models after loading saved settings
                            setTimeout(() => {
                                refreshModels();
                                refreshSingleModels();
                            }, 500);
                        } else if (data.success && !data.has_saved_settings) {
                            console.log('loadAISettings: No saved settings found');
                            updateSystemStatus('AI_SETTINGS // NO_SAVED_SETTINGS_FOUND');
                        } else {
                            console.log('loadAISettings: Failed to load settings:', data);
                            showTerminalAlert('Failed to load AI settings: ' + data.error, 'error');
                        }
                    } catch (error) {
                        console.error('Error loading AI settings:', error);
                        showTerminalAlert('Error loading AI settings: ' + error.message, 'error');
                    }
                }
                
                async function clearSavedAISettings() {
                    if (!confirm('Are you sure you want to clear all saved AI settings? This action cannot be undone.')) {
                        return;
                    }
                    
                    try {
                        const response = await fetch('/api/ai/clear-saved-settings', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            credentials: 'same-origin'
                        });
                        
                        const data = await response.json();
                        
                        if (data.success) {
                            // Don't reset UI - just clear the saved settings indicators
                            // Remove saved key indicators
                            ['aiApiKey', 'singleAiApiKey'].forEach(id => {
                                const input = document.getElementById(id);
                                if (input && input.hasAttribute('data-has-saved-key')) {
                                    input.removeAttribute('data-has-saved-key');
                                    input.placeholder = 'Enter API Key (any format accepted)';
                                }
                            });
                            
                            // Re-enable toggle buttons
                            ['toggleApiKeyVisibility', 'toggleSingleApiKeyVisibility'].forEach(id => {
                                const button = document.getElementById(id);
                                if (button) {
                                    button.disabled = false;
                                    button.style.opacity = '1';
                                    button.style.cursor = 'pointer';
                                    button.title = 'Show API key';
                                }
                            });
                            
                            showTerminalAlert('Saved AI settings cleared successfully', 'success');
                            updateSystemStatus('AI_SETTINGS // PERSISTENT_STORAGE_CLEARED');
                        } else {
                            showTerminalAlert('Failed to clear saved AI settings: ' + data.error, 'error');
                        }
                    } catch (error) {
                        console.error('Error clearing saved AI settings:', error);
                        showTerminalAlert('Error clearing saved AI settings: ' + error.message, 'error');
                    }
                }
                
                async function makeAISettingsPermanent() {
                    try {
                        // Get current UI settings (same as saveAISettings but without the enabled check)
                        const settings = getAIConfiguration();
                        console.log('Current UI settings to make permanent:', settings);
                        
                        const response = await fetch('/api/ai/save-settings', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            credentials: 'same-origin',
                            body: JSON.stringify({
                                settings: settings
                            })
                        });
                        
                        const data = await response.json();
                        
                        if (data.success) {
                            // Configure session with saved settings for immediate use
                            await configureSessionAfterSave(settings);
                            
                            showTerminalAlert('Current settings saved to permanent storage', 'success');
                            updateSystemStatus('AI_SETTINGS // CURRENT_SETTINGS_SAVED_PERMANENT');
                        } else {
                            showTerminalAlert('Failed to save current settings: ' + data.error, 'error');
                        }
                    } catch (error) {
                        console.error('Error saving current settings:', error);
                        showTerminalAlert('Error saving current settings: ' + error.message, 'error');
                    }
                }
                
                async function configureSessionAfterSave(settings) {
                    // Configure session with saved settings for immediate scraping use
                    try {
                        // Use the same /api/ai/configure endpoint that's used during scraping
                        const response = await fetch('/api/ai/configure', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            credentials: 'same-origin',
                            body: JSON.stringify(settings)
                        });
                        
                        const data = await response.json();
                        
                        if (data.success) {
                            console.log('Session configured with saved settings for immediate use');
                        } else {
                            console.warn('Failed to configure session:', data.error);
                        }
                    } catch (error) {
                        console.error('Error configuring session after save:', error);
                    }
                }
                
                function resetAISettingsUI() {
                    // Reset both single-page and multi-page AI settings to defaults
                    ['', 'single'].forEach(prefix => {
                        const enabledCheckbox = document.getElementById(prefix + 'AiEnhancementEnabled');
                        if (enabledCheckbox) {
                            enabledCheckbox.checked = false;
                        }
                        
                        const providerSelect = document.getElementById(prefix + 'LlmProvider');
                        if (providerSelect) {
                            providerSelect.value = 'openai';
                        }
                        
                        const apiKeyInput = document.getElementById(prefix + 'ApiKey');
                        if (apiKeyInput) {
                            apiKeyInput.value = '';
                            apiKeyInput.placeholder = 'Enter your API key';
                        }
                        
                        const thresholdSlider = document.getElementById(prefix + 'ConfidenceThreshold');
                        if (thresholdSlider) {
                            thresholdSlider.value = 0.7;
                            updateSliderValue(prefix + 'ConfidenceThreshold');
                        }
                        
                        // Reset custom questions
                        const questionsField = document.getElementById(prefix + 'CustomQuestions');
                        if (questionsField) {
                            questionsField.value = '';
                            const mode = prefix === 'single' ? 'single' : 'multi';
                            validateCustomQuestions(mode);
                        }
                        
                        // Reset all feature checkboxes
                        ['NutritionalAnalysis', 'PriceAnalysis', 'CuisineClassification', 'MultimodalAnalysis', 
                         'PatternLearning', 'DynamicPrompts'].forEach(feature => {
                            const checkbox = document.getElementById(prefix + feature);
                            if (checkbox) {
                                checkbox.checked = feature === 'NutritionalAnalysis' || feature === 'PriceAnalysis' || feature === 'CuisineClassification';
                            }
                        });
                    });
                    
                    // Hide AI config options
                    const configPanels = ['aiConfigOptions', 'singleAiConfigOptions'];
                    configPanels.forEach(panelId => {
                        const panel = document.getElementById(panelId);
                        if (panel) {
                            panel.style.display = 'none';
                        }
                    });
                }

                // Single Page AI Enhancement Functions
                function toggleSinglePageAIEnhancementOptions() {
                    const aiPanel = document.getElementById('singleAiEnhancementPanel');
                    const expandIcon = document.getElementById('singleAiEnhancementIcon');
                    
                    if (!aiPanel || !expandIcon) {
                        console.error('Single Page AI Enhancement elements not found:', {aiPanel, expandIcon});
                        return;
                    }
                    
                    const isCollapsed = aiPanel.classList.contains('collapsed');
                    
                    if (isCollapsed) {
                        aiPanel.classList.remove('collapsed');
                        expandIcon.textContent = '▲';
                        expandIcon.style.transform = 'rotate(180deg)';
                        updateSystemStatus('AI_ENHANCEMENT // SINGLE_PAGE_PANEL_EXPANDED');
                    } else {
                        aiPanel.classList.add('collapsed');
                        expandIcon.textContent = '▼';
                        expandIcon.style.transform = 'rotate(0deg)';
                        updateSystemStatus('AI_ENHANCEMENT // SINGLE_PAGE_PANEL_COLLAPSED');
                    }
                }

                function handleSinglePageAIEnhancementToggle() {
                    const enabledCheckbox = document.getElementById('singleAiEnhancementEnabled');
                    const configOptions = document.getElementById('singleAiConfigOptions');
                    
                    if (!enabledCheckbox || !configOptions) {
                        console.error('Single Page AI Enhancement toggle elements not found');
                        return;
                    }
                    
                    if (enabledCheckbox.checked) {
                        configOptions.classList.remove('collapsed');
                        updateSystemStatus('AI_ENHANCEMENT // SINGLE_PAGE_ENABLED_CONFIG_VISIBLE');
                        checkSinglePageProviderAvailability();
                    } else {
                        configOptions.classList.add('collapsed');
                        updateSystemStatus('AI_ENHANCEMENT // SINGLE_PAGE_DISABLED_TRADITIONAL_MODE');
                    }
                }

                function handleSinglePageProviderChange() {
                    const providerSelect = document.getElementById('singleLlmProvider');
                    const apiKeySection = document.getElementById('singleApiKeySection');
                    const localServiceStatus = document.getElementById('singleLocalServiceStatus');
                    const customProviderSection = document.getElementById('singleCustomProviderSection');
                    const modelSection = document.getElementById('singleModelSection');
                    const apiKeyInput = document.getElementById('singleAiApiKey');
                    
                    if (!providerSelect) return;
                    
                    const selectedProvider = providerSelect.value;
                    
                    // Show/hide sections based on provider
                    if (selectedProvider === 'openai' || selectedProvider === 'claude') {
                        apiKeySection.style.display = 'block';
                        localServiceStatus.style.display = 'none';
                        customProviderSection.style.display = 'none';
                        
                        // Show model selection for OpenAI, hide for others
                        if (selectedProvider === 'openai') {
                            modelSection.style.display = 'block';
                            apiKeyInput.placeholder = 'Enter OpenAI API Key (optional)';
                        } else {
                            modelSection.style.display = 'none';
                            apiKeyInput.placeholder = 'Enter Anthropic API Key (optional)';
                        }
                    } else if (selectedProvider === 'custom') {
                        apiKeySection.style.display = 'block';
                        localServiceStatus.style.display = 'none';
                        customProviderSection.style.display = 'block';
                        modelSection.style.display = 'none';
                        
                        // Update placeholder text for custom provider
                        apiKeyInput.placeholder = 'Enter API Key (any format accepted)';
                    } else {
                        // Local providers (ollama, llama_cpp)
                        apiKeySection.style.display = 'none';
                        localServiceStatus.style.display = 'block';
                        customProviderSection.style.display = 'none';
                        modelSection.style.display = 'none';
                        checkSinglePageLocalServiceStatus(selectedProvider);
                    }
                    
                    updateSystemStatus(`AI_PROVIDER // SINGLE_PAGE_${selectedProvider.toUpperCase()}_SELECTED`);
                }

                function checkSinglePageProviderAvailability() {
                    const providerSelect = document.getElementById('singleLlmProvider');
                    if (providerSelect) {
                        handleSinglePageProviderChange(); // Trigger initial provider setup
                    }
                }

                function checkSinglePageLocalServiceStatus(provider) {
                    const statusDot = document.getElementById('singleStatusDot');
                    const statusText = document.getElementById('singleStatusText');
                    
                    if (!statusDot || !statusText) return;
                    
                    // Set checking state
                    statusDot.className = 'status-dot checking';
                    statusText.textContent = 'Checking connection...';
                    
                    // Simulate checking local service (in real implementation, this would be an API call)
                    setTimeout(() => {
                        if (provider === 'ollama') {
                            // Check if Ollama is available (placeholder - would be real API call)
                            fetch('/api/ai/providers', { credentials: 'same-origin' })
                                .then(response => response.json())
                                .then(data => {
                                    const isAvailable = data.ollama?.available || false;
                                    updateSinglePageServiceStatus(isAvailable, provider);
                                })
                                .catch(() => {
                                    updateSinglePageServiceStatus(false, provider);
                                });
                        } else {
                            // For llama_cpp, just show as available (local binary)
                            updateSinglePageServiceStatus(true, provider);
                        }
                    }, 1000);
                }

                function updateSinglePageServiceStatus(isAvailable, provider) {
                    const statusDot = document.getElementById('singleStatusDot');
                    const statusText = document.getElementById('singleStatusText');
                    
                    if (!statusDot || !statusText) return;
                    
                    if (isAvailable) {
                        statusDot.className = 'status-dot connected';
                        statusText.textContent = `${provider} service available`;
                        statusText.style.color = 'var(--accent-green)';
                    } else {
                        statusDot.className = 'status-dot disconnected';
                        statusText.textContent = `${provider} service unavailable`;
                        statusText.style.color = 'var(--accent-red)';
                    }
                }

                function updateSinglePageConfidenceValue(value) {
                    const display = document.getElementById('singleConfidenceValue');
                    if (display) {
                        display.textContent = value;
                    }
                }
                
                // Toggle help text visibility for schema type information
                function toggleHelpText() {
                    console.log('toggleHelpText called');
                    const schemaHelpStatic = document.getElementById('schema-type-help-static');
                    console.log('schemaHelpStatic element:', schemaHelpStatic);
                    if (schemaHelpStatic) {
                        const helpContent = schemaHelpStatic.querySelector('.help-content');
                        const toggleArrow = schemaHelpStatic.querySelector('.toggle-help');
                        console.log('helpContent:', helpContent, 'toggleArrow:', toggleArrow);
                        
                        if (helpContent && toggleArrow) {
                            if (helpContent.style.display === 'none' || helpContent.classList.contains('hidden')) {
                                console.log('Showing help content');
                                helpContent.style.display = 'block';
                                helpContent.classList.remove('hidden');
                                helpContent.classList.add('visible');
                                toggleArrow.textContent = '▼';
                            } else {
                                console.log('Hiding help content');
                                helpContent.style.display = 'none';
                                helpContent.classList.add('hidden');
                                helpContent.classList.remove('visible');
                                toggleArrow.textContent = '▶';
                            }
                        }
                    }
                }

                function getAdvancedOptionsConfig() {
                    return {
                        pageDiscoveryEnabled: document.getElementById('pageDiscoveryEnabled').checked,
                        requestTimeout: parseInt(document.getElementById('requestTimeout').value),
                        concurrentRequests: parseInt(document.getElementById('concurrentRequests').value),
                        followRedirects: document.getElementById('followRedirects').checked,
                        respectRobotsTxt: document.getElementById('respectRobotsTxt').checked
                    };
                }

                function setupSliderUpdates() {
                    // Crawl depth slider
                    const crawlDepthSlider = document.getElementById('crawlDepth');
                    const depthValue = document.getElementById('depthValue');
                    
                    if (crawlDepthSlider && depthValue) {
                        crawlDepthSlider.addEventListener('input', function() {
                            depthValue.textContent = this.value;
                            updateSystemStatus(`CRAWL_DEPTH_SET // LEVEL_${this.value}`);
                        });
                    }

                    // Rate limit slider
                    const rateLimitSlider = document.getElementById('rateLimit');
                    const rateLimitValue = document.getElementById('rateLimitValue');
                    
                    if (rateLimitSlider && rateLimitValue) {
                        rateLimitSlider.addEventListener('input', function() {
                            rateLimitValue.textContent = this.value + 'ms';
                            updateSystemStatus(`RATE_LIMIT_SET // ${this.value}MS_DELAY`);
                        });
                    }

                    // JavaScript timeout slider
                    const jsTimeoutSlider = document.getElementById('jsTimeout');
                    const jsTimeoutValue = document.getElementById('jsTimeoutValue');
                    
                    if (jsTimeoutSlider && jsTimeoutValue) {
                        jsTimeoutSlider.addEventListener('input', function() {
                            jsTimeoutValue.textContent = this.value + 's';
                            updateSystemStatus(`JS_TIMEOUT_SET // ${this.value}S_LIMIT`);
                        });
                    }

                    // JavaScript rendering checkbox
                    const enableJavaScript = document.getElementById('enableJavaScript');
                    if (enableJavaScript) {
                        enableJavaScript.addEventListener('change', function() {
                            const status = this.checked ? 'ENABLED' : 'DISABLED';
                            updateSystemStatus(`JAVASCRIPT_RENDERING // ${status}`);
                        });
                    }

                    // Popup handling checkbox
                    const enablePopupHandling = document.getElementById('enablePopupHandling');
                    if (enablePopupHandling) {
                        enablePopupHandling.addEventListener('change', function() {
                            const status = this.checked ? 'ENABLED' : 'DISABLED';
                            updateSystemStatus(`POPUP_HANDLING // ${status}`);
                        });
                    }

                    // Max pages input
                    const maxPagesInput = document.getElementById('maxPages');
                    if (maxPagesInput) {
                        maxPagesInput.addEventListener('input', function() {
                            updateSystemStatus(`MAX_PAGES_SET // LIMIT_${this.value}_PAGES`);
                        });
                    }

                    // Pattern inputs
                    const includePatterns = document.getElementById('includePatterns');
                    const excludePatterns = document.getElementById('excludePatterns');
                    
                    if (includePatterns) {
                        includePatterns.addEventListener('input', function() {
                            const patterns = this.value.split(',').length;
                            updateSystemStatus(`INCLUDE_PATTERNS_SET // ${patterns}_FILTERS_ACTIVE`);
                        });
                    }

                    if (excludePatterns) {
                        excludePatterns.addEventListener('input', function() {
                            const patterns = this.value.split(',').length;
                            updateSystemStatus(`EXCLUDE_PATTERNS_SET // ${patterns}_FILTERS_ACTIVE`);
                        });
                    }

                    // Advanced Options Event Listeners
                    setupAdvancedOptionsEventListeners();
                }

                function setupAdvancedOptionsEventListeners() {
                    // Page Discovery toggle
                    const pageDiscoveryToggle = document.getElementById('pageDiscoveryEnabled');
                    if (pageDiscoveryToggle) {
                        pageDiscoveryToggle.addEventListener('change', togglePageDiscoveryWarning);
                    }

                    // Request timeout validation
                    const requestTimeout = document.getElementById('requestTimeout');
                    if (requestTimeout) {
                        requestTimeout.addEventListener('input', function() {
                            validateAdvancedOptions();
                            updateSystemStatus(`REQUEST_TIMEOUT_SET // ${this.value}S_LIMIT`);
                        });
                    }

                    // Concurrent requests slider
                    const concurrentRequests = document.getElementById('concurrentRequests');
                    if (concurrentRequests) {
                        concurrentRequests.addEventListener('input', function() {
                            updateConcurrentRequestsDisplay();
                            updateSystemStatus(`CONCURRENT_REQUESTS_SET // ${this.value}_SIMULTANEOUS`);
                        });
                    }

                    // Follow redirects toggle
                    const followRedirects = document.getElementById('followRedirects');
                    if (followRedirects) {
                        followRedirects.addEventListener('change', function() {
                            const status = this.checked ? 'ENABLED' : 'DISABLED';
                            updateSystemStatus(`FOLLOW_REDIRECTS // ${status}`);
                        });
                    }

                    // Respect robots.txt toggle
                    const respectRobotsTxt = document.getElementById('respectRobotsTxt');
                    if (respectRobotsTxt) {
                        respectRobotsTxt.addEventListener('change', function() {
                            const status = this.checked ? 'ENABLED' : 'DISABLED';
                            updateSystemStatus(`RESPECT_ROBOTS_TXT // ${status}`);
                        });
                    }

                    // Initialize display values
                    updateConcurrentRequestsDisplay();
                    togglePageDiscoveryWarning();
                }

                function setupModeSelection() {
                    const modeOptions = document.querySelectorAll('.mode-option');
                    const multiPageHeader = document.getElementById('multiPageHeader');
                    const multiPageConfig = document.getElementById('multiPageConfig');
                    const singlePageHeader = document.getElementById('singlePageHeader');
                    const singlePageConfig = document.getElementById('singlePageConfig');
                    
                    modeOptions.forEach(option => {
                        option.addEventListener('click', function() {
                            // Update active state
                            modeOptions.forEach(opt => opt.classList.remove('active'));
                            this.classList.add('active');
                            
                            // Update radio button
                            const radio = this.querySelector('input[type="radio"]');
                            radio.checked = true;
                            
                            // Show/hide configuration panels based on mode
                            const mode = radio.value;
                            if (mode === 'multi') {
                                // Show multi-page config, hide single-page config
                                multiPageHeader.style.display = 'block';
                                singlePageHeader.style.display = 'none';
                                
                                // AUTO-EXPAND multi-page config so advanced options are accessible
                                if (multiPageConfig) {
                                    multiPageConfig.classList.remove('collapsed');
                                    const multiExpandIcon = document.getElementById('configExpandIcon');
                                    if (multiExpandIcon) {
                                        multiExpandIcon.classList.add('expanded');
                                        multiExpandIcon.textContent = '▲';
                                    }
                                }
                                
                                // Collapse single-page config if it was expanded
                                if (singlePageConfig) {
                                    singlePageConfig.classList.add('collapsed');
                                    const singleExpandIcon = document.getElementById('singleConfigExpandIcon');
                                    if (singleExpandIcon) singleExpandIcon.classList.remove('expanded');
                                }
                                
                                updateSystemStatus('MULTI_PAGE_MODE // ADVANCED_CRAWLING_ENABLED');
                            } else {
                                // Show single-page config, hide multi-page config
                                singlePageHeader.style.display = 'block';
                                multiPageHeader.style.display = 'none';
                                
                                // AUTO-EXPAND single-page config so advanced options are accessible
                                if (singlePageConfig) {
                                    singlePageConfig.classList.remove('collapsed');
                                    const singleExpandIcon = document.getElementById('singleConfigExpandIcon');
                                    if (singleExpandIcon) {
                                        singleExpandIcon.classList.add('expanded');
                                        singleExpandIcon.textContent = '▲';
                                    }
                                }
                                
                                // Collapse multi-page config if it was expanded
                                if (multiPageConfig) {
                                    multiPageConfig.classList.add('collapsed');
                                    const expandIcon = document.getElementById('configExpandIcon');
                                    if (expandIcon) expandIcon.classList.remove('expanded');
                                }
                                
                                updateSystemStatus('SINGLE_PAGE_MODE // DIRECT_URL_PROCESSING');
                            }
                        });
                    });
                }

                function updateSystemStatus(message) {
                    if (statusBar) {
                        statusBar.textContent = message;
                        statusBar.style.animation = 'pulse 0.5s ease-in-out';
                        setTimeout(() => {
                            if (statusBar) statusBar.style.animation = '';
                        }, 500);
                    }
                }

                function terminalLog(message, type = 'info') {
                    const timestamp = new Date().toISOString().substr(11, 8);
                    const prefix = type === 'error' ? '[ERROR]' : 
                                 type === 'success' ? '[SUCCESS]' : '[INFO]';
                    return `[${timestamp}] ${prefix} ${message}`;
                }
                
                // Validate URLs on input with terminal feedback
                urlsInput.addEventListener('input', debounce(validateURLsInput, 500));
                
                // Form submission with terminal aesthetics
                form.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    console.log('Form submission started');
                    
                    // Check input mode first
                    const inputModeElement = document.querySelector('input[name="input_mode"]:checked');
                    const inputMode = inputModeElement ? inputModeElement.value : 'url';
                    console.log('Input mode detection:');
                    console.log('- inputModeElement:', inputModeElement);
                    console.log('- inputMode:', inputMode);
                    console.log('- All radio buttons:', document.querySelectorAll('input[name="input_mode"]'));
                    
                    // Handle file upload mode
                    if (inputMode === 'file') {
                        console.log('File upload mode detected - processing files');
                        updateSystemStatus('FILE_PROCESSING // FILE_UPLOAD_MODE_DETECTED');
                        
                        // Check for both uploaded files and file path input
                        const fileInput = document.getElementById('file-input');
                        const files = fileInput ? fileInput.files : [];
                        
                        // The container should already be visible in file mode, but ensure it
                        
                        const filePathInput = document.getElementById('file-path-input');
                        const filePath = filePathInput ? filePathInput.value.trim() : '';
                        
                        console.log('DEBUG: File input detection:');
                        console.log('- fileInput element:', fileInput);
                        console.log('- files.length:', files.length);
                        console.log('- filePathInput element:', filePathInput);
                        console.log('- filePath value:', filePath);
                        
                        const fileContainer = document.getElementById('file-upload-container');
                        
                        // Check if we have any files or path - be more flexible
                        const hasFiles = files && files.length > 0;
                        const hasPath = filePath && filePath.length > 0;
                        
                        if (!hasFiles && !hasPath) {
                            updateSystemStatus('ERROR // NO_FILES_OR_PATH_PROVIDED');
                            showTerminalAlert('CRITICAL ERROR: No files selected or file path provided. Please upload PDF files or enter a file path.');
                            return;
                        }
                        
                        // Prioritize file path over uploaded files if both are provided
                        if (filePath) {
                            console.log('Processing file path:', filePath);
                            updateSystemStatus('FILE_PROCESSING // PROCESSING_FILE_PATH');
                            
                            // Process file path directly (simulate file upload for backend)
                            const filePathData = {
                                file_paths: [filePath],
                                industry: getSelectedIndustry()
                            };
                            
                            fetch('/api/process-file-path', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                },
                                body: JSON.stringify(filePathData)
                            })
                            .then(response => response.json())
                            .then(data => {
                                if (data.success) {
                                    showTerminalAlert('File path processing completed successfully.');
                                    updateSystemStatus('FILE_PROCESSING // COMPLETED');
                                } else {
                                    showTerminalAlert('File path processing failed: ' + data.error);
                                    updateSystemStatus('FILE_PROCESSING // ERROR');
                                }
                            })
                            .catch(error => {
                                showTerminalAlert('File path processing failed: ' + error.message);
                                updateSystemStatus('FILE_PROCESSING // ERROR');
                            });
                            return;
                        }
                        
                        // Process uploaded files using existing API endpoints
                        updateSystemStatus('FILE_PROCESSING // UPLOADING_FILES');
                        
                        // Get uploaded files from queue
                        const uploadQueue = document.getElementById('upload-queue');
                        const fileItems = uploadQueue.querySelectorAll('.file-item');
                        
                        if (fileItems.length === 0) {
                            showTerminalAlert('No files selected for processing.');
                            updateSystemStatus('FILE_PROCESSING // NO_FILES');
                            return;
                        }
                        
                        // Upload files first, then process them
                        processUploadedFiles();
                        return;
                    }
                    
                    // URL mode processing
                    console.log('URL mode detected - processing URLs');
                    console.log('urlsInput element:', urlsInput);
                    console.log('urlsInput.value:', urlsInput.value);
                    // Extract URLs using regex to handle quotes and other text
                    const urlPattern = /https?:\/\/[^\s"']+(?:\/[^\s"']*)*\/?/g;
                    const urls = urlsInput.value.match(urlPattern) || [];
                    
                    // If no URLs found with regex, fall back to newline splitting
                    if (urls.length === 0) {
                        const lines = urlsInput.value.trim().split('\n').filter(line => line.trim());
                        urls.push(...lines);
                    }
                    console.log('Processed URLs:', urls);
                    console.log('URLs length:', urls.length);
                    
                    const outputDir = document.getElementById('outputDir').value.trim();
                    const fileMode = document.getElementById('fileMode').value;
                    const fileFormat = document.querySelector('input[name="fileFormat"]:checked').value;
                    const scrapingMode = document.querySelector('input[name="scrapingMode"]:checked').value;
                    
                    // Collect JSON field selections if JSON format is selected
                    let jsonFieldSelections = null;
                    if (fileFormat === 'json') {
                        const selectedFields = Array.from(document.querySelectorAll('input[name="jsonFields"]:checked'))
                            .map(input => input.value);
                        if (selectedFields.length > 0) {
                            jsonFieldSelections = selectedFields;
                        }
                    }
                    
                    if (urls.length === 0) {
                        updateSystemStatus('ERROR // NO_TARGET_URLs_DETECTED');
                        showTerminalAlert('CRITICAL ERROR: No target URLs detected. Please input valid restaurant URLs.');
                        return;
                    }
                    
                    // Collect multi-page configuration if multi-page mode is selected
                    let multiPageConfig = null;
                    if (scrapingMode === 'multi') {
                        // Always provide default multi-page configuration
                        multiPageConfig = {
                            maxPages: parseInt(document.getElementById('maxPages')?.value) || 50,
                            crawlDepth: parseInt(document.getElementById('crawlDepth')?.value) || 2,
                            includePatterns: document.getElementById('includePatterns')?.value || 'menu,food,restaurant',
                            excludePatterns: document.getElementById('excludePatterns')?.value || 'admin,login,cart',
                            rateLimit: parseInt(document.getElementById('rateLimit')?.value) || 1000
                        };
                        
                        // Add advanced options if validation passes
                        if (validateAdvancedOptions()) {
                            const advancedOptions = getAdvancedOptionsConfig();
                            multiPageConfig = {
                                ...multiPageConfig,
                                ...advancedOptions
                            };
                        }
                        
                        // Add AI configuration
                        const aiConfig = getAIConfiguration();
                        multiPageConfig = {
                            ...multiPageConfig,
                            ai_config: aiConfig
                        };
                    }
                    
                    updateSystemStatus(`INITIATING_EXTRACTION // ${urls.length}_TARGETS_QUEUED // ${scrapingMode.toUpperCase()}_MODE`);
                    await startScraping(urls, outputDir, fileMode, fileFormat, jsonFieldSelections, scrapingMode, multiPageConfig);
                });
                
                // Validate button with terminal feedback
                validateBtn.addEventListener('click', () => {
                    // Check input mode first
                    const inputModeElement = document.querySelector('input[name="input_mode"]:checked');
                    const inputMode = inputModeElement ? inputModeElement.value : 'url';
                    
                    if (inputMode === 'file') {
                        updateSystemStatus('FILE_MODE // VALIDATION_NOT_APPLICABLE');
                        showTerminalAlert('URL validation is not applicable in file upload mode.');
                        return;
                    }
                    
                    updateSystemStatus('VALIDATING_TARGETS // SCANNING_URLs...');
                    validateURLsInput();
                });
                
                // Clear button with terminal reset
                clearBtn.addEventListener('click', () => {
                    form.reset();
                    urlValidation.innerHTML = '';
                    hideResults();
                    hideProgress();
                    // Reset format selection
                    formatOptions.forEach(opt => opt.classList.remove('selected'));
                    formatOptions[0].classList.add('selected');
                    updateSystemStatus('TERMINAL_RESET // AWAITING_NEW_TARGETS');
                });

                function showTerminalAlert(message) {
                    const alertDiv = document.createElement('div');
                    alertDiv.className = 'terminal-alert';
                    alertDiv.style.cssText = `
                        position: fixed;
                        top: 20px;
                        right: 20px;
                        background: rgba(255, 85, 85, 0.9);
                        border: 1px solid #ff5555;
                        color: white;
                        padding: 1rem;
                        font-family: 'JetBrains Mono', monospace;
                        font-size: 0.875rem;
                        z-index: 1000;
                        max-width: 400px;
                        animation: slideInRight 0.3s ease-out;
                    `;
                    alertDiv.textContent = message;
                    document.body.appendChild(alertDiv);
                    
                    setTimeout(() => {
                        if (alertDiv.parentNode) {
                            alertDiv.remove();
                        }
                    }, 4000);
                }
                
                async function processUploadedFiles() {
                    try {
                        // Get file input element
                        const fileInput = document.getElementById('file-input');
                        if (!fileInput || !fileInput.files || fileInput.files.length === 0) {
                            showTerminalAlert('No files selected for upload.');
                            return;
                        }
                        
                        // Create FormData for file upload
                        const formData = new FormData();
                        const files = Array.from(fileInput.files);
                        
                        // Add files to FormData
                        files.forEach(file => {
                            formData.append('files', file);
                        });
                        
                        updateSystemStatus('FILE_PROCESSING // UPLOADING_FILES');
                        
                        // Upload files first
                        const uploadResponse = await fetch('/api/upload/batch', {
                            method: 'POST',
                            body: formData
                        });
                        
                        const uploadResult = await uploadResponse.json();
                        
                        if (!uploadResult.success) {
                            showTerminalAlert('File upload failed: ' + uploadResult.error);
                            updateSystemStatus('FILE_PROCESSING // UPLOAD_ERROR');
                            return;
                        }
                        
                        updateSystemStatus('FILE_PROCESSING // PROCESSING_FILES');
                        
                        // Get AI configuration
                        const aiConfig = getAIConfiguration();
                        
                        // Process uploaded files
                        const processResponse = await fetch('/api/process-uploaded-files-for-rag', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                file_ids: uploadResult.file_ids,
                                file_paths: [],
                                output_dir: '',
                                file_mode: 'single',
                                file_format: document.querySelector('input[name="fileFormat"]:checked').value,
                                json_field_selections: (() => {
                                    const fileFormat = document.querySelector('input[name="fileFormat"]:checked').value;
                                    if (fileFormat === 'json') {
                                        const selectedFields = Array.from(document.querySelectorAll('input[name="jsonFields"]:checked'))
                                            .map(input => input.value);
                                        return selectedFields.length > 0 ? selectedFields : null;
                                    }
                                    return null;
                                })(),
                                scraping_mode: getSelectedScrapingMode(),
                                multi_page_config: (() => {
                                    const scrapingMode = getSelectedScrapingMode();
                                    if (scrapingMode === 'multi') {
                                        return {
                                            maxPages: parseInt(document.getElementById('maxPages')?.value) || 50,
                                            crawlDepth: parseInt(document.getElementById('crawlDepth')?.value) || 2,
                                            includePatterns: document.getElementById('includePatterns')?.value || 'menu,food,restaurant',
                                            excludePatterns: document.getElementById('excludePatterns')?.value || 'admin,login,cart',
                                            rateLimit: parseInt(document.getElementById('rateLimit')?.value) || 1000
                                        };
                                    }
                                    return {};
                                })(),
                                industry: getSelectedIndustry(),
                                schema_type: getSelectedSchemaType(),
                                // Add AI configuration to the request
                                ai_enhancement_enabled: aiConfig.ai_enhancement_enabled,
                                llm_provider: aiConfig.llm_provider,
                                api_key: aiConfig.api_key,
                                ai_features: aiConfig.ai_features,
                                confidence_threshold: aiConfig.confidence_threshold,
                                custom_questions: aiConfig.custom_questions
                            })
                        });
                        
                        const processResult = await processResponse.json();
                        
                        if (processResult.success) {
                            showTerminalAlert(`Successfully processed ${processResult.processed_count} files.`);
                            updateSystemStatus('FILE_PROCESSING // COMPLETED');
                            
                            
                            // Show processing results using the same function as URL scraping
                            showResults(processResult, true);
                        } else {
                            showTerminalAlert('File processing failed: ' + processResult.error);
                            updateSystemStatus('FILE_PROCESSING // PROCESSING_ERROR');
                        }
                        
                    } catch (error) {
                        showTerminalAlert('File processing failed: ' + error.message);
                        updateSystemStatus('FILE_PROCESSING // ERROR');
                    }
                }
                
                function showFileProcessingResults(data) {
                    const resultsContainer = document.getElementById('resultsContainer');
                    const noResults = document.getElementById('no-results');
                    
                    if (resultsContainer) {
                        resultsContainer.style.display = 'block';
                        noResults.style.display = 'none';
                        
                        let html = `
                            <div class="results-header">
                                <h3>File Processing Results</h3>
                                <p>Processed ${data.processed_count} files successfully</p>
                            </div>
                        `;
                        
                        if (data.results) {
                            data.results.forEach((result, index) => {
                                const status = result.success ? 'SUCCESS' : 'FAILED';
                                const statusClass = result.success ? 'success' : 'error';
                                
                                html += `
                                    <div class="file-result ${statusClass}">
                                        <h4>File ${index + 1} - ${status}</h4>
                                        ${result.success ? 
                                            `<p>Method: ${result.method_used}</p>
                                             <p>Pages: ${result.page_count}</p>` :
                                            `<p>Error: ${result.error}</p>`
                                        }
                                    </div>
                                `;
                            });
                        }
                        
                        resultsContainer.innerHTML = html;
                    }
                }
                
                async function validateURLsInput() {
                    // Check input mode first - only validate URLs in URL mode
                    const inputModeElement = document.querySelector('input[name="input_mode"]:checked');
                    const inputMode = inputModeElement ? inputModeElement.value : 'url';
                    
                    if (inputMode === 'file') {
                        // In file mode, clear any URL validation and don't validate
                        urlValidation.innerHTML = '';
                        updateSystemStatus('FILE_MODE // URL_VALIDATION_SKIPPED');
                        return;
                    }
                    
                    // Extract URLs using regex to handle quotes and other text
                    const urlPattern = /https?:\/\/[^\s"']+(?:\/[^\s"']*)*\/?/g;
                    const urls = urlsInput.value.match(urlPattern) || [];
                    
                    // If no URLs found with regex, fall back to newline splitting
                    if (urls.length === 0) {
                        const lines = urlsInput.value.trim().split('\n').filter(line => line.trim());
                        urls.push(...lines);
                    }
                    
                    if (urls.length === 0) {
                        urlValidation.innerHTML = '';
                        updateSystemStatus('SYSTEM_READY // AWAITING_TARGET_URLs');
                        return;
                    }
                    
                    updateSystemStatus(`VALIDATING // ${urls.length}_TARGETS_SCANNING...`);
                    
                    try {
                        const response = await fetch('/api/validate', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({ urls: urls })
                        });
                        
                        const data = await response.json();
                        
                        if (data.results) {
                            displayValidationResults(data.results);
                        }
                    } catch (error) {
                        console.error('Validation error:', error);
                        urlValidation.innerHTML = terminalLog('VALIDATION_FAILED // Network error', 'error');
                        updateSystemStatus('ERROR // VALIDATION_SYSTEM_OFFLINE');
                    }
                }
                
                function displayValidationResults(results) {
                    const validCount = results.filter(r => r.is_valid).length;
                    const totalCount = results.length;
                    const status = validCount === totalCount ? 'ALL_VALID' : `${validCount}/${totalCount}_VALID`;
                    
                    updateSystemStatus(`VALIDATION_COMPLETE // ${status}`);
                    
                    let html = `<div style="margin-bottom: 0.5rem;">${terminalLog(`Target analysis: ${validCount}/${totalCount} URLs validated`, 'info')}</div>`;
                    
                    results.forEach((result, index) => {
                        const cssClass = result.is_valid ? 'valid-url' : 'invalid-url';
                        const status = result.is_valid ? '[VALID]' : '[INVALID]';
                        const error = result.error ? ` // ${result.error}` : '';
                        
                        html += `<div class="${cssClass}">${status} TARGET_${index + 1}${error}</div>`;
                    });
                    
                    urlValidation.innerHTML = html;
                }
                
                async function startScraping(urls, outputDir, fileMode, fileFormat, jsonFieldSelections, scrapingMode, multiPageConfig) {
                    submitBtn.disabled = true;
                    submitBtn.textContent = 'EXTRACTION_IN_PROGRESS...';
                    showProgress();
                    hideResults();
                    
                    const industry = document.getElementById('industry').value;
                    updateSystemStatus(`EXTRACTION_INITIATED // ${urls.length}_TARGETS_PROCESSING`);
                    
                    try {
                        // Create AbortController for longer timeout (10 minutes for multi-page scraping)
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 600000); // 10 minutes
                        
                        const response = await fetch('/api/scrape', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            signal: controller.signal,
                            body: JSON.stringify({
                                urls: urls,
                                output_dir: outputDir,
                                file_mode: fileMode,
                                file_format: fileFormat,
                                industry: industry,
                                json_field_selections: jsonFieldSelections,
                                scraping_mode: scrapingMode,
                                multi_page_config: multiPageConfig,
                                enableJavaScript: document.getElementById('enableJavaScript')?.checked || false,
                                jsTimeout: parseInt(document.getElementById('jsTimeout')?.value || '30'),
                                enablePopupHandling: document.getElementById('enablePopupHandling')?.checked || true,
                                schema_type: getSelectedSchemaType(),
                                restw_schema: getSelectedSchemaType() === 'RestW',  // Backwards compatibility
                                session_id: generateSessionId(),  // Generate session ID for AI analysis
                                ai_config: getAIConfiguration()  // Include AI configuration
                            })
                        });
                        
                        clearTimeout(timeoutId);
                        
                        const data = await response.json();
                        
                        // Debug logging to help identify the issue
                        console.log('API Response:', data);
                        console.log('Processed count:', data.processed_count);
                        console.log('Sites data:', data.sites_data);
                        console.log('Output files:', data.output_files);
                        
                        if (data.success) {
                            updateSystemStatus(`EXTRACTION_COMPLETE // ${data.processed_count || 0}_TARGETS_PROCESSED`);
                            showResults(data, true);
                            // Clear the URLs input field after successful scraping
                            urlsInput.value = '';
                        } else {
                            updateSystemStatus('EXTRACTION_FAILED // SYSTEM_ERROR');
                            showResults(data, false);
                        }
                    } catch (error) {
                        console.error('Scraping error:', error);
                        
                        let errorMessage = 'Unknown error during extraction';
                        let statusMessage = 'CRITICAL_ERROR // UNKNOWN_FAILURE';
                        
                        if (error.name === 'AbortError') {
                            errorMessage = 'Request timeout - multi-page scraping took longer than 10 minutes';
                            statusMessage = 'TIMEOUT_ERROR // PROCESSING_TIMEOUT';
                        } else if (error.message && error.message.includes('fetch')) {
                            errorMessage = 'Network connection failure during extraction';
                            statusMessage = 'NETWORK_ERROR // CONNECTION_FAILURE';
                        } else if (error.message) {
                            errorMessage = error.message;
                            statusMessage = 'REQUEST_ERROR // ' + error.name;
                        }
                        
                        updateSystemStatus(statusMessage);
                        showResults({ error: errorMessage }, false);
                    } finally {
                        submitBtn.disabled = false;
                        submitBtn.textContent = 'EXECUTE_EXTRACTION';
                        hideProgress();
                    }
                }
                
                function showProgress() {
                    progressContainer.style.display = 'block';
                    progressFill.style.width = '0%';
                    progressText.textContent = terminalLog('Initializing extraction sequence...', 'info');
                    currentUrl.textContent = '';
                    timeEstimate.textContent = '';
                    memoryUsage.textContent = '';
                    
                    // Activate the data flow pipeline
                    if (dataFlow) {
                        dataFlow.classList.add('active');
                    }
                    
                    // Start progress polling
                    progressInterval = setInterval(updateProgress, 1000);
                }
                
                function hideProgress() {
                    progressContainer.style.display = 'none';
                    
                    // Deactivate the data flow pipeline
                    if (dataFlow) {
                        dataFlow.classList.remove('active');
                    }
                    
                    if (progressInterval) {
                        clearInterval(progressInterval);
                        progressInterval = null;
                    }
                }
                
                async function updateProgress() {
                    try {
                        const response = await fetch('/api/progress');
                        const data = await response.json();
                        
                        if (data.progress_percentage !== undefined) {
                            progressFill.style.width = data.progress_percentage + '%';
                            progressText.textContent = terminalLog(`Extraction progress: ${data.progress_percentage}% (${data.urls_completed}/${data.urls_total})`, 'info');
                            
                            if (data.current_url) {
                                currentUrl.textContent = terminalLog(`Processing target: ${data.current_url}`, 'info');
                            }
                            
                            if (data.estimated_time_remaining > 0) {
                                const minutes = Math.floor(data.estimated_time_remaining / 60);
                                const seconds = Math.floor(data.estimated_time_remaining % 60);
                                timeEstimate.textContent = terminalLog(`ETA: ${minutes}m ${seconds}s`, 'info');
                            } else if (data.urls_completed > 0) {
                                timeEstimate.textContent = terminalLog('Calculating time estimate...', 'info');
                            }
                            
                            if (data.memory_usage_mb > 0) {
                                memoryUsage.textContent = terminalLog(`Memory usage: ${data.memory_usage_mb.toFixed(1)} MB`, 'info');
                            }
                            
                            if (data.current_operation) {
                                progressText.textContent = terminalLog(data.current_operation, 'info');
                            }
                            
                            // Enhanced real-time progress visualization
                            updateRealTimeProgress(data);
                        }
                    } catch (error) {
                        console.error('Progress update error:', error);
                    }
                }
                
                function updateRealTimeProgress(data) {
                    // Show/hide real-time progress based on multi-page mode
                    if (data.multi_page_mode && data.total_pages > 1) {
                        realTimeProgress.style.display = 'block';
                        
                        // Update current page being processed
                        if (data.current_page_url) {
                            currentPageUrl.textContent = data.current_page_url;
                            currentPageUrl.classList.add('pulsing');
                        }
                        
                        // Update queue metrics
                        const completed = data.pages_completed || 0;
                        const total = data.total_pages || 0;
                        const inQueue = data.pages_in_queue || 0;
                        const remaining = total - completed;
                        const processing = data.currently_processing || (data.current_page_url ? 1 : 0);
                        
                        pagesCompleted.textContent = completed;
                        pagesInQueue.textContent = inQueue;
                        pagesRemaining.textContent = remaining;
                        currentlyProcessing.textContent = processing;
                        
                        // Update time estimates
                        if (data.estimated_remaining_time !== undefined) {
                            estimatedTimeRemaining.textContent = `~${data.estimated_remaining_time.toFixed(1)}s`;
                        }
                        
                        if (data.average_processing_time !== undefined) {
                            averageProcessingTime.textContent = `${data.average_processing_time.toFixed(1)}s`;
                        }
                        
                        // Handle new page discoveries
                        if (data.new_pages_discovered && data.new_pages_discovered > 0) {
                            showDiscoveryNotification(data.new_pages_discovered);
                        }
                    } else {
                        realTimeProgress.style.display = 'none';
                    }
                }
                
                function showDiscoveryNotification(count) {
                    const notification = document.createElement('div');
                    notification.className = 'notification';
                    notification.innerHTML = `
                        <span class="icon">🔍</span>
                        <span class="message">New pages discovered: ${count}</span>
                    `;
                    
                    discoveryNotifications.insertBefore(notification, discoveryNotifications.firstChild);
                    
                    // Remove old notifications (keep max 5)
                    while (discoveryNotifications.children.length > 5) {
                        discoveryNotifications.removeChild(discoveryNotifications.lastChild);
                    }
                    
                    // Auto-remove after 10 seconds
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.remove();
                        }
                    }, 10000);
                }
                
                function showResults(data, success) {
                    resultsContainer.style.display = 'block';
                    
                    if (success && data.sites_data) {
                        // Show enhanced results display
                        showEnhancedResults(data);
                    } else if (success) {
                        // Show legacy results display for backward compatibility
                        showLegacyResults(data, success);
                    } else {
                        // Show error results
                        showErrorResults(data);
                    }
                }

                function showEnhancedResults(data) {
                    noResults.style.display = 'none';
                    sitesResults.style.display = 'block';
                    
                    const scrapingMode = getSelectedScrapingMode();
                    const sitesData = data.sites_data || [];
                    
                    // Store sites data globally for "Show all pages" functionality
                    window.currentSitesData = sitesData;
                    
                    let html = '';
                    
                    // Add output files section if available
                    if (data.output_files && data.output_files.length > 0) {
                        html += `<div style="margin-bottom: 1rem;">${terminalLog('Generated output files:', 'info')}</div>`;
                        html += '<div class="file-links" style="margin-bottom: 1.5rem;">';
                        data.output_files.forEach(file => {
                            const fileName = file.split('/').pop();
                            const fileExtension = fileName.split('.').pop().toLowerCase();
                            
                            // For text files, create a view link that opens in browser
                            // For PDF files, create a download link
                            if (fileExtension === 'txt' || fileExtension === 'json') {
                                const viewUrl = `/api/view-file/${encodeURIComponent(fileName)}`;
                                html += `<a href="${viewUrl}" target="_blank" class="file-link">${fileName}</a>`;
                            } else {
                                const downloadUrl = `/api/download/${encodeURIComponent(fileName)}`;
                                html += `<a href="${downloadUrl}" target="_blank" class="file-link">${fileName}</a>`;
                            }
                        });
                        html += '</div>';
                    }
                    
                    sitesData.forEach((siteData, index) => {
                        html += generateSiteResultHTML(siteData, index, scrapingMode);
                    });
                    
                    sitesResults.innerHTML = html;
                    
                    // Set up event listeners for interactive elements
                    setupResultsInteractivity();
                }

                function showLegacyResults(data, success) {
                    // Keep existing functionality for backward compatibility
                    noResults.style.display = 'none';
                    sitesResults.style.display = 'none';
                    
                    let html = '';
                    
                    html += `<div style="margin-bottom: 1rem;">${terminalLog('EXTRACTION_COMPLETE // All targets processed successfully', 'success')}</div>`;
                    
                    if (data.processed_count) {
                        html += `<div>${terminalLog(`Targets processed: ${data.processed_count}`, 'info')}</div>`;
                    }
                    
                    if (data.output_files && data.output_files.length > 0) {
                        html += `<div style="margin: 1rem 0;">${terminalLog('Generated output files:', 'info')}</div>`;
                        html += '<div class="file-links">';
                        data.output_files.forEach(file => {
                            const fileName = file.split('/').pop();
                            const fileExtension = fileName.split('.').pop().toLowerCase();
                            
                            // For text files, create a view link that opens in browser
                            // For PDF files, create a download link
                            if (fileExtension === 'txt' || fileExtension === 'json') {
                                const viewUrl = `/api/view-file/${encodeURIComponent(fileName)}`;
                                html += `<a href="${viewUrl}" target="_blank" class="file-link">${fileName}</a>`;
                            } else {
                                const downloadUrl = `/api/download/${encodeURIComponent(fileName)}`;
                                html += `<a href="${downloadUrl}" target="_blank" class="file-link">${fileName}</a>`;
                            }
                        });
                        html += '</div>';
                    }
                    
                    if (data.failed_count && data.failed_count > 0) {
                        html += `<div style="margin-top: 1rem;">${terminalLog(`Failed targets: ${data.failed_count}`, 'error')}</div>`;
                    }
                    
                    if (data.processing_time) {
                        html += `<div>${terminalLog(`Processing time: ${data.processing_time.toFixed(2)}s`, 'info')}</div>`;
                    }
                    
                    resultsContent.innerHTML = html;
                }

                function showErrorResults(data) {
                    noResults.style.display = 'none';
                    sitesResults.style.display = 'none';
                    
                    let html = '';
                    html += `<div>${terminalLog('EXTRACTION_FAILED // System error detected', 'error')}</div>`;
                    html += `<div style="margin-top: 0.5rem;">${terminalLog(`Error details: ${data.error || 'Unknown system failure'}`, 'error')}</div>`;
                    
                    resultsContent.innerHTML = html;
                }

                function generateSiteResultHTML(siteData, index, scrapingMode) {
                    console.log('generateSiteResultHTML called with:', siteData);
                    const { site_url, pages_processed, pages } = siteData;
                    console.log('Extracted values:', { site_url, pages_processed, pages });
                    const successCount = pages.filter(p => p.status === 'success').length;
                    const failedCount = pages.filter(p => p.status === 'failed').length;
                    
                    // Check if any pages have relationship data
                    const hasRelationships = pages.some(p => p.relationship);
                    const isMultiPageMode = scrapingMode === 'multi';
                    
                    let html = `
                        <div class="site-result ${hasRelationships && isMultiPageMode ? 'relationship-enabled' : ''}">
                            <div class="site-header" onclick="toggleSiteExpansion(${index})">
                                <div class="site-url">${site_url}</div>
                                <div class="pages-summary">
                                    <span>Pages Processed: ${pages_processed}</span>
                                    <div class="processing-stats">
                                        <div class="stat-item">
                                            <div class="stat-icon success"></div>
                                            <span>${successCount} success</span>
                                        </div>
                                        <div class="stat-item">
                                            <div class="stat-icon failed"></div>
                                            <span>${failedCount} failed</span>
                                        </div>
                                    </div>
                                    <div class="expand-toggle" id="toggle-${index}">▼</div>
                                </div>
                            </div>
                            <div class="pages-list" id="pages-${index}">
                    `;
                    
                    if (hasRelationships && isMultiPageMode) {
                        // Generate relationship tree for multi-page mode
                        html += generateRelationshipTree(pages, index);
                    } else {
                        // Generate simple page list for single-page mode or no relationships
                        const pagesToShow = pages.slice(0, 5);
                        const hasMorePages = pages.length > 5;
                        
                        pagesToShow.forEach(page => {
                            html += generatePageItemHTML(page, isMultiPageMode);
                        });
                        
                        if (hasMorePages) {
                            html += `
                                <div class="show-all-link" onclick="showAllPages(${index})">
                                    Show all ${pages.length} pages
                                </div>
                            `;
                        }
                    }
                    
                    html += `
                            </div>
                        </div>
                    `;
                    
                    return html;
                }

                function generatePageItemHTML(page, showRelationships = false) {
                    const statusClass = `status-${page.status}`;
                    const statusText = page.status === 'success' ? '✓ SUCCESS' : 
                                     page.status === 'failed' ? '✗ FAILED' :
                                     page.status === 'timeout' ? '⏰ TIMEOUT' :
                                     page.status === 'redirected' ? '↪ REDIRECTED' : '? UNKNOWN';
                    const statusClassName = page.status === 'success' ? 'success' : 
                                          page.status === 'failed' ? 'failed' :
                                          page.status === 'timeout' ? 'timeout' :
                                          page.status === 'redirected' ? 'redirected' : 'unknown';
                    
                    let relationshipClasses = '';
                    let relationshipContent = '';
                    
                    if (page.relationship && showRelationships) {
                        const rel = page.relationship;
                        relationshipClasses = `relationship-${rel.type} depth-${rel.depth || 0}`;
                        
                        if (rel.error) {
                            relationshipClasses += ' broken-relationship';
                        }
                        
                        // Add relationship indicator
                        if (rel.type === 'root') {
                            relationshipContent += '<span class="relationship-indicator ROOT">ROOT</span>';
                            relationshipContent += '<span class="discovery-info">Entry point</span>';
                        } else if (rel.type === 'child') {
                            relationshipContent += '<span class="indentation"></span>';
                            relationshipContent += '<span class="relationship-indicator child">↳</span>';
                            if (rel.parent_url) {
                                relationshipContent += `<span class="parent-reference">from: ${rel.parent_url}</span>`;
                                relationshipContent += `<span class="discovery-info">Discovered from: ${rel.parent_url}</span>`;
                            }
                        } else if (rel.type === 'orphaned') {
                            relationshipContent += '<span class="relationship-indicator orphaned">⚠ ORPHANED</span>';
                        }
                        
                        // Add children count if applicable
                        if (rel.children_count > 0) {
                            relationshipContent += `<span class="children-count">Children discovered: ${rel.children_count}</span>`;
                        }
                        
                        // Add depth level
                        if (rel.depth !== undefined) {
                            relationshipContent += `<span class="depth-level">Depth level: ${rel.depth}</span>`;
                        }
                        
                        // Add discovery method
                        if (rel.discovery_method) {
                            relationshipContent += `<span class="discovery-info">${rel.discovery_method}</span>`;
                        }
                        
                        // Add error indicators
                        if (rel.error) {
                            relationshipContent += '<span class="relationship-warning">⚠ Relationship broken</span>';
                        }
                        
                        // Add tooltip
                        const tooltipText = `Type: ${rel.type}, Depth: ${rel.depth || 0}, Discovery: ${rel.discovery_method || 'unknown'}`;
                        relationshipContent += `<span class="relationship-tooltip" data-tooltip="${tooltipText}">ℹ</span>`;
                    }
                    
                    // Generate detailed status information
                    let statusDetails = '';
                    let tooltipData = '';
                    
                    if (page.status === 'success') {
                        statusDetails += `
                            <span class="http-status">${page.http_status || 200}</span>
                            <span class="data-count">${page.data_extracted || 0} items</span>
                            <span class="content-size">${formatContentSize(page.content_size || 0)}</span>
                        `;
                        tooltipData = `Status: ${page.http_status || 200} | Data: ${page.data_extracted || 0} items | Size: ${formatContentSize(page.content_size || 0)} | Method: ${page.extraction_method || 'unknown'}`;
                    } else if (page.status === 'failed') {
                        statusDetails += `
                            <span class="http-status">${page.http_status || 'N/A'}</span>
                            <span class="error-message">${page.error_message || 'Unknown error'}</span>
                        `;
                        tooltipData = `Status: ${page.http_status || 'N/A'} | Error: ${page.error_message || 'Unknown error'}`;
                    } else if (page.status === 'timeout') {
                        statusDetails += `
                            <span class="timeout-duration">${page.timeout_duration || 30.0}s</span>
                            ${page.partial_data ? `<span class="partial-data">${page.partial_data} items</span>` : ''}
                        `;
                        tooltipData = `Timeout: ${page.timeout_duration || 30.0}s | Partial data: ${page.partial_data || 0} items`;
                    } else if (page.status === 'redirected') {
                        statusDetails += `
                            <span class="final-url">→ ${page.final_url || page.url}</span>
                            ${page.redirect_chain ? `<span class="redirect-count">${page.redirect_chain.length} redirects</span>` : ''}
                        `;
                        tooltipData = `Final URL: ${page.final_url || page.url} | Redirects: ${page.redirect_chain ? page.redirect_chain.length : 1}`;
                    }
                    
                    // Add timestamp to tooltip
                    if (page.timestamp) {
                        tooltipData += ` | Time: ${formatTimestamp(page.timestamp)}`;
                    }

                    return `
                        <div class="page-item ${statusClass} ${relationshipClasses}" 
                             onmouseover="highlightRelationshipChain('${page.url}')"
                             onmouseout="clearRelationshipHighlight()"
                             title="${tooltipData}">
                            ${relationshipContent}
                            <div class="page-url">${page.url}</div>
                            <div class="page-status-container">
                                <div class="page-status ${statusClassName}">${statusText}</div>
                                <div class="status-details">${statusDetails}</div>
                            </div>
                            <div class="page-time ${getPerformanceRating(page.processing_time || 0)}" 
                                 title="${generateProcessingTimeTooltip(page)}">
                                ${formatProcessingTime(page.processing_time || 0)}
                                <span class="performance-indicator ${getPerformanceRating(page.processing_time || 0)}"></span>
                            </div>
                            ${generateAIAnalysisDisplay(page)}
                        </div>
                    `;
                }

                function generateAIAnalysisDisplay(page) {
                    if (!page.ai_analysis) {
                        return '';
                    }
                    
                    const ai = page.ai_analysis;
                    console.log('AI Analysis Data:', ai);
                    const confidencePercentage = Math.round(ai.confidence_score * 100);
                    const confidenceColor = ai.meets_threshold ? 'var(--accent-green)' : 'var(--accent-amber)';
                    const thresholdIcon = ai.meets_threshold ? '✓' : '⚠';
                    
                    return `
                        <div class="ai-analysis-container" style="margin-top: 0.5rem; padding: 0.5rem; background: rgba(0, 255, 136, 0.1); border-left: 2px solid var(--accent-green); border-radius: 3px;">
                            <div class="ai-header" style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.25rem;">
                                <span class="ai-icon">🤖</span>
                                <span class="ai-provider" style="font-size: 0.75rem; color: var(--text-secondary);">
                                    ${ai.provider_used || 'AI'} Enhanced
                                </span>
                                <span class="ai-confidence" style="font-size: 0.75rem; color: ${confidenceColor};">
                                    ${thresholdIcon} ${confidencePercentage}%
                                </span>
                            </div>
                            <div class="ai-features" style="display: flex; flex-wrap: wrap; gap: 0.25rem; font-size: 0.7rem;">
                                ${ai.has_nutritional_info ? '<span class="ai-feature" style="background: rgba(0, 255, 136, 0.2); padding: 0.1rem 0.3rem; border-radius: 2px;">🥗 Nutrition</span>' : ''}
                                ${ai.has_price_info ? '<span class="ai-feature" style="background: rgba(255, 170, 0, 0.2); padding: 0.1rem 0.3rem; border-radius: 2px;">💰 Pricing</span>' : ''}
                                ${ai.has_cuisine_info ? '<span class="ai-feature" style="background: rgba(0, 170, 255, 0.2); padding: 0.1rem 0.3rem; border-radius: 2px;">🍽️ Cuisine</span>' : ''}
                                ${ai.confidence_score > 0 ? '<span class="ai-feature" style="background: rgba(0, 255, 136, 0.2); padding: 0.1rem 0.3rem; border-radius: 2px;">🤖 Enhanced</span>' : ''}
                            </div>
                            ${ai.error ? `<div class="ai-error" style="color: var(--accent-amber); font-size: 0.7rem; margin-top: 0.25rem;">⚠ ${ai.error}</div>` : ''}
                        </div>
                    `;
                }

                function formatContentSize(sizeBytes) {
                    if (!sizeBytes || sizeBytes === 0) return "0 B";
                    if (sizeBytes < 1024) return `${sizeBytes} B`;
                    if (sizeBytes < 1048576) return `${(sizeBytes / 1024).toFixed(1)} KB`;
                    return `${(sizeBytes / 1048576).toFixed(1)} MB`;
                }

                function formatTimestamp(timestampStr) {
                    if (!timestampStr) return "";
                    try {
                        const date = new Date(timestampStr);
                        return date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
                    } catch (e) {
                        return timestampStr;
                    }
                }

                function formatProcessingTime(timeSeconds) {
                    if (!timeSeconds || timeSeconds === 0) return "0.00s";
                    if (timeSeconds < 60) {
                        return `${timeSeconds.toFixed(2)}s`;
                    } else {
                        const minutes = Math.floor(timeSeconds / 60);
                        const seconds = timeSeconds % 60;
                        return `${minutes}m ${seconds.toFixed(2)}s`;
                    }
                }

                function getPerformanceRating(timeSeconds) {
                    if (!timeSeconds || timeSeconds < 1.0) return 'excellent';
                    if (timeSeconds < 5.0) return 'good';
                    if (timeSeconds < 10.0) return 'slow';
                    return 'very_slow';
                }

                function generateProcessingTimeTooltip(page) {
                    const totalTime = page.processing_time || 0;
                    const networkTime = page.network_time || 0;
                    const parsingTime = page.parsing_time || 0;
                    const extractionTime = page.extraction_time || 0;
                    
                    let tooltip = `Total: ${totalTime.toFixed(2)}s`;
                    
                    if (networkTime > 0) tooltip += ` | Network: ${networkTime.toFixed(2)}s`;
                    if (parsingTime > 0) tooltip += ` | Parsing: ${parsingTime.toFixed(2)}s`;
                    if (extractionTime > 0) tooltip += ` | Extraction: ${extractionTime.toFixed(2)}s`;
                    
                    // Add speed metrics if available
                    if (page.content_size && totalTime > 0) {
                        const bytesPerSec = (page.content_size / totalTime);
                        tooltip += ` | Speed: ${formatContentSize(bytesPerSec)}/s`;
                    }
                    
                    if (page.data_extracted && totalTime > 0) {
                        const itemsPerSec = (page.data_extracted / totalTime).toFixed(1);
                        tooltip += ` | Rate: ${itemsPerSec} items/s`;
                    }
                    
                    return tooltip;
                }

                function setupResultsInteractivity() {
                    // Event listeners are set up via onclick attributes in HTML
                    // This function can be extended for additional interactivity
                }

                function toggleSiteExpansion(siteIndex) {
                    const pagesList = document.getElementById(`pages-${siteIndex}`);
                    const toggle = document.getElementById(`toggle-${siteIndex}`);
                    
                    if (pagesList.classList.contains('expanded')) {
                        pagesList.classList.remove('expanded');
                        toggle.classList.remove('expanded');
                    } else {
                        pagesList.classList.add('expanded');
                        toggle.classList.add('expanded');
                    }
                }

                function showAllPages(siteIndex) {
                    // Show all pages for a specific site
                    const pagesList = document.getElementById(`pages-${siteIndex}`);
                    const showAllLink = pagesList.querySelector('.show-all-link');
                    
                    // Get the site's data from the global sites results
                    if (window.currentSitesData && window.currentSitesData[siteIndex]) {
                        const siteData = window.currentSitesData[siteIndex];
                        const isMultiPageMode = getSelectedScrapingMode() === 'multi';
                        
                        // Clear current content
                        pagesList.innerHTML = '';
                        
                        // Show all pages
                        siteData.pages.forEach(page => {
                            pagesList.innerHTML += generatePageItemHTML(page, isMultiPageMode);
                        });
                        
                        // Add a "Show less" link
                        pagesList.innerHTML += `
                            <div class="show-all-link" onclick="showLessPages(${siteIndex})">
                                Show less
                            </div>
                        `;
                    }
                }
                
                function showLessPages(siteIndex) {
                    // Show only first 5 pages again
                    const pagesList = document.getElementById(`pages-${siteIndex}`);
                    
                    if (window.currentSitesData && window.currentSitesData[siteIndex]) {
                        const siteData = window.currentSitesData[siteIndex];
                        const isMultiPageMode = getSelectedScrapingMode() === 'multi';
                        const pagesToShow = siteData.pages.slice(0, 5);
                        const hasMorePages = siteData.pages.length > 5;
                        
                        // Clear and regenerate limited view
                        pagesList.innerHTML = '';
                        
                        pagesToShow.forEach(page => {
                            pagesList.innerHTML += generatePageItemHTML(page, isMultiPageMode);
                        });
                        
                        if (hasMorePages) {
                            pagesList.innerHTML += `
                                <div class="show-all-link" onclick="showAllPages(${siteIndex})">
                                    Show all ${siteData.pages.length} pages
                                </div>
                            `;
                        }
                    }
                }

                function getSelectedScrapingMode() {
                    const modeInput = document.querySelector('input[name="scrapingMode"]:checked');
                    return modeInput ? modeInput.value : 'single';
                }
                
                function getSelectedIndustry() {
                    const industrySelect = document.getElementById('industry');
                    return industrySelect ? industrySelect.value : 'restaurant';
                }
                
                function getSelectedSchemaType() {
                    const schemaTypeDropdown = document.getElementById('schema-type-dropdown');
                    return schemaTypeDropdown ? schemaTypeDropdown.value : 'Restaurant';
                }
                
                function handleSchemaTypeChange(schemaType) {
                    console.log('Schema type changed to:', schemaType);
                    
                    // Update help text based on schema type
                    const helpTextElement = document.getElementById('schema-type-help-static');
                    if (helpTextElement) {
                        // Update help text content dynamically
                        updateSchemaTypeHelpText(schemaType);
                    }
                    
                    // Show/hide RestW-specific options if they exist
                    const restwOptions = document.querySelectorAll('.restw-specific');
                    restwOptions.forEach(option => {
                        if (schemaType === 'RestW') {
                            option.style.display = 'block';
                        } else {
                            option.style.display = 'none';
                        }
                    });
                    
                    // Update dropdown selection (for consistency)
                    const dropdown = document.getElementById('schema-type-dropdown');
                    if (dropdown && dropdown.value !== schemaType) {
                        dropdown.value = schemaType;
                    }
                }
                
                function updateSchemaTypeHelpText(schemaType) {
                    const helpTextElement = document.getElementById('schema-type-help-static');
                    if (!helpTextElement) return;
                    
                    // Find the content div inside the static element
                    const contentDiv = helpTextElement.querySelector('.help-content');
                    if (!contentDiv) return;
                    
                    let content = '';
                    if (schemaType === 'Restaurant') {
                        content = `
                            <h4>Restaurant Schema - Standard Extraction</h4>
                            <p>Standard restaurant data extraction provides comprehensive information about restaurants including:</p>
                            <ul>
                                <li><strong>Basic Information:</strong> Restaurant name, description, and cuisine type</li>
                                <li><strong>Menu Information:</strong> Menu items, prices, and categories</li>
                                <li><strong>Location and Contact:</strong> Address, phone number, and website</li>
                                <li><strong>Business Hours:</strong> Operating hours and special schedules</li>
                                <li><strong>Services:</strong> Available services like delivery, takeout, and reservations</li>
                            </ul>
                            <p>This schema provides reliable extraction for most restaurant websites and documents.</p>
                        `;
                    } else if (schemaType === 'RestW') {
                        content = `
                            <h4>RestW Schema - Enhanced Restaurant Data</h4>
                            <p>Enhanced restaurant data extraction with specialized fields and advanced processing:</p>
                            <ul>
                                <li><strong>Structured Location Data:</strong> Detailed address formatting with neighborhood information</li>
                                <li><strong>Advanced Menu Item Extraction:</strong> Menu items with detailed categorization and pricing</li>
                                <li><strong>Service Offerings:</strong> Comprehensive service information including delivery zones</li>
                                <li><strong>Enhanced Contact Info:</strong> Multiple contact methods with formatted display</li>
                                <li><strong>Web Links:</strong> Social media links, online menus, and reservation systems</li>
                            </ul>
                            <p>This schema provides enhanced extraction capabilities for complex restaurant data.</p>
                        `;
                    }
                    
                    const helpContent = helpTextElement.querySelector('.help-content');
                    if (helpContent) {
                        helpContent.innerHTML = content;
                    }
                }

                // Page Relationship Functions
                function generateRelationshipTree(pages, siteIndex) {
                    let html = '<div class="relationship-tree">';
                    html += '<div class="relationship-tree-header">🌳 PAGE RELATIONSHIP TREE</div>';
                    
                    // Sort pages by depth for hierarchical display
                    const sortedPages = pages.slice().sort((a, b) => {
                        const depthA = a.relationship?.depth || 0;
                        const depthB = b.relationship?.depth || 0;
                        return depthA - depthB;
                    });
                    
                    // Group orphaned pages separately
                    const orphanedPages = pages.filter(p => p.relationship?.type === 'orphaned');
                    const hierarchicalPages = pages.filter(p => p.relationship?.type !== 'orphaned');
                    
                    // Generate hierarchical pages
                    hierarchicalPages.forEach((page, index) => {
                        html += generatePageItemHTML(page, true);
                    });
                    
                    // Generate orphaned pages section if any exist
                    if (orphanedPages.length > 0) {
                        html += '<div class="orphaned-section">';
                        html += '<div class="orphaned-section-header">⚠ ORPHANED PAGES</div>';
                        orphanedPages.forEach(page => {
                            html += generatePageItemHTML(page, true);
                        });
                        html += '</div>';
                    }
                    
                    // Add relationship statistics
                    html += generateRelationshipStats(pages);
                    
                    html += '</div>';
                    return html;
                }

                function generateRelationshipStats(pages) {
                    const stats = {
                        total: pages.length,
                        root: pages.filter(p => p.relationship?.type === 'root').length,
                        children: pages.filter(p => p.relationship?.type === 'child').length,
                        orphaned: pages.filter(p => p.relationship?.type === 'orphaned').length,
                        maxDepth: Math.max(...pages.map(p => p.relationship?.depth || 0)),
                        totalRelationships: pages.filter(p => p.relationship?.parent_url).length
                    };
                    
                    return `
                        <div class="relationship-stats">
                            <div class="relationship-stats-grid">
                                <div class="stat-row">
                                    <span class="stat-label">Total Pages:</span>
                                    <span class="stat-value">${stats.total}</span>
                                </div>
                                <div class="stat-row">
                                    <span class="stat-label">Root Pages:</span>
                                    <span class="stat-value">${stats.root}</span>
                                </div>
                                <div class="stat-row">
                                    <span class="stat-label">Child Pages:</span>
                                    <span class="stat-value">${stats.children}</span>
                                </div>
                                <div class="stat-row">
                                    <span class="stat-label">Orphaned Pages:</span>
                                    <span class="stat-value">${stats.orphaned}</span>
                                </div>
                                <div class="stat-row">
                                    <span class="stat-label">Max Depth:</span>
                                    <span class="stat-value">${stats.maxDepth}</span>
                                </div>
                                <div class="stat-row">
                                    <span class="stat-label">Total Relationships:</span>
                                    <span class="stat-value">${stats.totalRelationships}</span>
                                </div>
                            </div>
                        </div>
                    `;
                }

                function highlightRelationshipChain(targetUrl) {
                    // Get all page items in the current site
                    const pageItems = document.querySelectorAll('.page-item');
                    
                    // Clear existing highlights
                    pageItems.forEach(item => {
                        item.classList.remove('highlighted');
                    });
                    
                    // Find related pages and highlight them
                    const relatedUrls = findRelatedPages(targetUrl);
                    
                    pageItems.forEach(item => {
                        const urlElement = item.querySelector('.page-url');
                        if (urlElement && relatedUrls.includes(urlElement.textContent)) {
                            item.classList.add('highlighted');
                        }
                    });
                    
                    // Add highlighting effect to container
                    const container = document.querySelector('.relationship-enabled');
                    if (container) {
                        container.classList.add('highlight-relationship-chain');
                    }
                }

                function clearRelationshipHighlight() {
                    const pageItems = document.querySelectorAll('.page-item');
                    pageItems.forEach(item => {
                        item.classList.remove('highlighted');
                    });
                    
                    const container = document.querySelector('.relationship-enabled');
                    if (container) {
                        container.classList.remove('highlight-relationship-chain');
                    }
                }

                function findRelatedPages(targetUrl) {
                    // This is a simplified version - in a real implementation,
                    // this would traverse the actual relationship data
                    const related = [targetUrl];
                    
                    // Find pages that mention this URL as parent
                    const pageItems = document.querySelectorAll('.page-item');
                    pageItems.forEach(item => {
                        const parentRef = item.querySelector('.parent-reference');
                        if (parentRef && parentRef.textContent.includes(targetUrl)) {
                            const urlElement = item.querySelector('.page-url');
                            if (urlElement) {
                                related.push(urlElement.textContent);
                            }
                        }
                    });
                    
                    return related;
                }

                function toggleRelationshipTreeExpansion(siteIndex) {
                    const tree = document.querySelector(`#pages-${siteIndex} .relationship-tree`);
                    if (tree) {
                        tree.classList.toggle('expanded');
                    }
                }
                
                function hideResults() {
                    resultsContainer.style.display = 'none';
                }
                
                function debounce(func, wait) {
                    let timeout;
                    return function executedFunction(...args) {
                        const later = () => {
                            clearTimeout(timeout);
                            func(...args);
                        };
                        clearTimeout(timeout);
                        timeout = setTimeout(later, wait);
                    };
                }
                
                function toggleSinglePageConfig() {
                    const configPanel = document.getElementById('singlePageConfig');
                    const expandIcon = document.getElementById('singleConfigExpandIcon');
                    const header = document.getElementById('singlePageHeader');
                    
                    if (configPanel.classList.contains('collapsed')) {
                        configPanel.classList.remove('collapsed');
                        expandIcon.classList.add('expanded');
                        if (header) header.setAttribute('aria-expanded', 'true');
                        console.log('Single page config expanded');
                    } else {
                        configPanel.classList.add('collapsed');
                        expandIcon.classList.remove('expanded');
                        if (header) header.setAttribute('aria-expanded', 'false');
                        console.log('Single page config collapsed');
                    }
                }

                // Add CSS animations for terminal effects
                const styleSheet = document.createElement('style');
                styleSheet.textContent = `
                    @keyframes float {
                        0%, 100% { transform: translateY(0px) rotate(0deg); opacity: 0.1; }
                        50% { transform: translateY(-10px) rotate(180deg); opacity: 0.3; }
                    }
                    
                    @keyframes slideInRight {
                        from { transform: translateX(100%); opacity: 0; }
                        to { transform: translateX(0); opacity: 1; }
                    }
                    
                    @keyframes terminal-cursor {
                        0%, 50% { box-shadow: inset 0 0 0 2px var(--accent-green); }
                        51%, 100% { box-shadow: inset 0 0 0 2px transparent; }
                    }
                `;
                document.head.appendChild(styleSheet);
                
                // File Upload Scripts
                {{ file_upload_scripts | safe }}
                
                // Separate Save Settings Scripts
                {{ single_page_save_settings_javascript | safe }}
                {{ multi_page_save_settings_javascript | safe }}
                
                // Single Page Advanced Options Toggle Function
                window.toggleSinglePageAdvancedOptions = function() {
                    const advancedPanel = document.getElementById('singleAdvancedOptionsPanel');
                    const expandIcon = document.getElementById('singleAdvancedOptionsIcon');
                    
                    if (!advancedPanel || !expandIcon) return;
                    
                    const isCollapsed = advancedPanel.classList.contains('collapsed');
                    
                    if (isCollapsed) {
                        advancedPanel.classList.remove('collapsed');
                        advancedPanel.style.display = 'block';
                        advancedPanel.style.maxHeight = '600px';
                        advancedPanel.style.opacity = '1';
                        advancedPanel.style.padding = '1.5rem';
                        expandIcon.textContent = '▼';
                    } else {
                        advancedPanel.classList.add('collapsed');
                        advancedPanel.style.display = 'none';
                        advancedPanel.style.maxHeight = '0';
                        advancedPanel.style.opacity = '0';
                        advancedPanel.style.padding = '0';
                        expandIcon.textContent = '▶';
                    }
                };
                
                function validateCustomQuestions(mode) {
                    const prefix = mode === 'single' ? 'single' : '';
                    const fieldId = prefix ? 'singleCustomQuestions' : 'customQuestions';
                    const descId = prefix ? 'singleCustomQuestionsDesc' : 'customQuestionsDesc';
                    
                    const textarea = document.getElementById(fieldId);
                    const desc = document.getElementById(descId);
                    
                    if (!textarea || !desc) return;
                    
                    const text = textarea.value;
                    const lines = text.split('\n').filter(line => line.trim().length > 0);
                    
                    let hasError = false;
                    let errorCount = 0;
                    
                    lines.forEach(line => {
                        if (line.trim().length > 200) {
                            hasError = true;
                            errorCount++;
                        }
                    });
                    
                    if (hasError) {
                        desc.textContent = `⚠️ ${errorCount} question(s) exceed 200 character limit`;
                        desc.style.color = 'var(--accent-red)';
                    } else {
                        desc.textContent = `${lines.length} custom question(s) (200 char limit per question)`;
                        desc.style.color = 'var(--text-secondary)';
                    }
                }
                
                function parseCustomQuestions(prefix) {
                    const fieldId = prefix ? 'singleCustomQuestions' : 'customQuestions';
                    const textarea = document.getElementById(fieldId);
                    
                    if (!textarea) return [];
                    
                    const text = textarea.value;
                    const lines = text.split('\n')
                        .map(line => line.trim())
                        .filter(line => line.length > 0)
                        .filter(line => line.length <= 200); // Only include questions within limit
                    
                    return lines;
                }
            </script>
        </body>
        </html>
